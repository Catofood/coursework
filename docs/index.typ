#import "lib/gost.typ": *
#import "lib/titlepage.typ": *

#titlepage(
  title: "АНАЛИТИЧЕСКИЙ МИКРОСЕРВИС ДЛЯ БОТА С РАСПИСАНИЕМ ГУАП",
  authors: ("И.К. Крылов",),
  teachers: ("А.А. Фоменкова",),
  date: datetime.today(),
  education: "МИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ РОССИЙСКОЙ ФЕДЕРАЦИИ
федеральное государственное автономное образовательное учреждение высшего образования
 «САНКТ-ПЕТЕРБУРГСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ 
АЭРОКОСМИЧЕСКОГО ПРИБОРОСТРОЕНИЯ»",
  department: "КАФЕДРА КОМПЬЮТЕРНЫХ ТЕХНОЛОГИЙ И ПРОГРАММНОЙ ИНЖЕНЕРИИ",
  position: "Доцент, к.т.н",
  documentName: "ПОЯСНИТЕЛЬНАЯ ЗАПИСКА
К КУРСОВОЙ РАБОТЕ (ПРОЕКТУ)",
  group: "М411",
  city: "Санкт-Петербург",
  object: "",
)


#show: doc => init(doc)

#ch("ВВЕДЕНИЕ")

Актуальность разработки аналитического микросервиса для Telegram-бота расписания ГУАП обусловлена растущей необходимостью отслеживания и анализа использования информационной системы. Миграция бота на облачную инфраструктуру и его интеграция с микросервисной архитектурой требует разработки специализированного сервиса для сбора, хранения и анализа метрик использования.

Целью работы является разработка микросервиса аналитики, который обеспечивает сбор событий использования бота в реальном времени через Kafka, хранение структурированных данных о пользователях, запросах и событиях обновления, предоставление REST API для получения статистики использования бота и интеграцию с основным сервисом SuaiScheduleBot через асинхронную очередь сообщений.

Задачи работы включают анализ предметной области и выявление требований, проектирование архитектуры микросервиса с использованием принципов Clean Architecture, реализацию слоев Domain, Application, Infrastructure и API, разработку компонентов для потребления событий из Kafka, создание репозиториев и запросов к базе данных PostgreSQL, разработку и тестирование API endpoints для получения аналитики, документирование кода и написание пояснительной записки.
#pagebreak()

= Анализ предметной области

== Первичная постановка задачи

Разрабатываемый микросервис SuaiScheduleBotAnalytics предназначен для сбора, обработки и предоставления статистики использования Telegram-бота расписания ГУАП. Основной сервис SuaiScheduleBot при выполнении пользовательских действий (просмотр расписания, подписка на группу и т.д.) отправляет сообщения в очередь Kafka. Сервис аналитики должен потреблять эти события и сохранять их в базе данных для последующего анализа.

Требования к системе: сбор событий от основного бота в реальном времени; хранение информации о пользователях, группах, запросах и обновлениях; предоставление API для получения различных метрик и статистики; поддержка фильтрации данных по временным периодам; обеспечение надежности и масштабируемости системы; соответствие принципам Clean Architecture для обеспечения maintainability.
\ 

== Анализ предметной области

В контексте разработки данной системы ключевыми понятиями являются:

*Пользователь* — зарегистрированный пользователь Telegram, взаимодействующий с ботом расписания. Каждый пользователь идентифицируется уникальным Telegram ID и содержит информацию о дате регистрации, предпочитаемой группе и истории запросов.

*Группа* — академическая группа ГУАП (например, М411, М412 и т.д.). Пользователи могут просматривать расписание различных групп и подписываться на избранные группы.

*Запрос пользователя* — действие пользователя в боте, включающее просмотр расписания для конкретной группы. Каждый запрос содержит тип запроса, временную метку, ссылку на пользователя и группу.

*Событие обновления* — событие, возникающее при обновлении информации о пользователе (например, при подписке на новую группу). Хранит тип события, пользователя и группу.

*Метрика* — агрегированные данные о использовании системы, включая количество пользователей, популярные группы, пиковые часы использования.

Проблема, решаемая данным микросервисом: основной бот генерирует большое количество событий, которые требуют обработки, хранения и анализа. Централизованный микросервис аналитики позволяет отделить логику сбора метрик от основной логики бота, обеспечивая лучшую масштабируемость и производительность системы.
\ 

== Анализ возможных методов решения
=== Архитектурные подходы

При разработке микросервиса были рассмотрены следующие архитектурные подходы:

*Монолитная архитектура* -- интеграция модуля аналитики непосредственно в основной бот. Преимущества: простота развертывания, прямой доступ к данным. Недостатки: увеличение связанности кода, сложность масштабирования, влияние на производительность основного сервиса.

*Микросервисная архитектура* (выбранный вариант) -- отдельный независимый сервис для аналитики, взаимодействующий с основным ботом через асинхронную очередь Kafka. Преимущества: разделение ответственности, независимая масштабируемость, асинхронная обработка не влияет на основной сервис. Недостатки: повышенная сложность развертывания, необходимость управления распределенными транзакциями.

*Real-time streaming* -- использование Apache Kafka Streams или Event Sourcing для обработки событий. Преимущества: высокая производительность, возможность обработки больших объемов данных. Недостатки: сложность разработки, требует специализированных знаний.

Выбранный вариант (микросервисная архитектура) обеспечивает оптимальный баланс между простотой разработки, масштабируемостью и отделением ответственности.
\ 
=== Технологические решения

*Фреймворк и язык* -- ASP.NET Core 9 с языком C\# был выбран за счет встроенной поддержки внедрения зависимостей (DI), наличия удобных библиотек для работы с Kafka (MassTransit), хорошей производительности и экосистемы, удобства разработки и мощных инструментов.

*Управление данными* -- Entity Framework Core (EF Core) с PostgreSQL обеспечивает объектно-реляционное отображение (ORM), миграции БД, поддержку сложных запросов и транзакционность.

*Потребление событий* -- MassTransit + Kafka обеспечивает гибкую конфигурацию потребителей, автоматическое управление подписками, поддержку retry-логики и легкую интеграцию с DI контейнером.

*Паттерны проектирования* -- Clean Architecture (без DDD) обеспечивает четкое разделение слоев, независимость от деталей реализации, облегчает тестирование и упрощает поддержку и расширение.
\ 

== Цель разработки

Создание масштабируемого микросервиса для сбора и анализа метрик использования Telegram-бота расписания ГУАП, обеспечивающий асинхронную обработку событий без влияния на производительность основного сервиса.

== Основные задачи

+ Проектирование архитектуры микросервиса включает разделение логики на четыре слоя: Domain, Application, Infrastructure и WebApi, в соответствии с принципами Clean Architecture.

+ Определение доменных моделей (UserEntity, GroupEntity, RequestEntity, UpdateEntity) и их отношений в системе для правильного представления бизнес-сущностей.

+ Реализация потребителей Kafka (UserPerformedRequestConsumer, UserUpdatedMessageConsumer) для асинхронной обработки событий от основного бота без нарушения его производительности.

+ Разработка репозиториев и абстракций доступа к данным для операций создания, чтения и фильтрации данных из базы.

+ Создание REST API endpoints (StatisticsController) с использованием MediatR для обработки запросов статистики и предоставления метрик администраторам.

+ Обеспечение интеграции с PostgreSQL через Entity Framework Core с поддержкой миграций баз данных и оптимизацией LINQ запросов.

+ Реализация валидации входных данных и обработки ошибок на уровне Application слоя с выбросом типизированных исключений.

+ Разработка Docker Compose конфигурации для упрощения локальной разработки и production развертывания микросервиса.

+ Создание полной документации REST API через Swagger/OpenAPI с описанием всех endpoints, параметров и примеров ответов.

+ Проведение комплексного тестирования компонентов и интеграционных тестов для обеспечения качества реализации всех требований.

#pagebreak()

\ 

= Разработка и анализ требований к программе
== Требования к пользовательскому интерфейсу

Микросервис аналитики предоставляет REST API, взаимодействие с которым осуществляется через HTTP запросы. Пользователями API являются как администраторы для получения статистики, так и различные микросервисы экосистемы.

== Требования к эндпоинтам

API документация предоставляется через Swagger UI по адресу `http://localhost:5000/swagger/index.html` при запуске приложения в режиме отладки.

StatisticsController предоставляет методы с базовым URL `/api/statistics`. Контроллер содержит набор endpoint'ов для получения аналитических данных о использовании бота.

+ *Базовый URL*: все эндпоинты доступны по адресу `/api/statistics`

+ *Метод запроса*: все эндпоинты используют HTTP метод GET для получения данных

+ *Формат параметров*: параметры передаются через query string в формате ISO 8601 для дат (`DateTimeOffset`)

+ *Формат ответа*: все ответы возвращаются в формате JSON с соответствующими HTTP статус-кодами

+ *Валидация параметров*: система проводит валидацию входных параметров и возвращает HTTP 400 при некорректных значениях

+ *Обработка ошибок*: система обрабатывает различные сценарии ошибок:
  HTTP 200: успешное выполнение запроса с возвращением данных
  HTTP 400: некорректные параметры запроса (некорректный формат дат, дата начала позже даты окончания, параметр `top` вне диапазона 1-100, будущая дата)
  HTTP 404: запрошенные данные не найдены в системе
  HTTP 500: внутренняя ошибка сервера

+ *Кодирование*: все строковые параметры должны быть правильно закодированы в URL

+ *Временные интервалы*: параметры `from` и `to` позволяют фильтровать данные по периодам, оба параметра опциональны. Если `from` не указан, берется начало истории, если `to` не указан, берется текущий момент времени

+ *Пагинация результатов*: для эндпоинтов с топ-N результатами используется параметр `top` (от 1 до 100, по умолчанию 10)

Описание функциональности каждого конкретного эндпоинта представлено ниже с соответствующими примерами запросов и ответов.

\ 
== Требования к интеграции программы с Kafka 
Микросервис потребляет события из двух топиков: `suai.user-performed-request` (события о запросах пользователя) и `suai.user-updated-message` (события об обновлении информации пользователя).

*Сообщения Kafka*: оба типа сообщений наследуют от `BaseUserMessage` с полями `TelegramUserId` и `OccuredAt`. Сообщение `UserPerformedRequestMessage` содержит `RequestType` (Search, RoomSchedule, GroupSchedule, TeacherSchedule) и опциональное `GroupName`. Сообщение `UserUpdatedMessage` содержит `UpdateType` (Registered, SubscribedToGroup, SetDefaultSettings, SetCustomSettings) и опциональное `SubscriptionGroupName`.

== Требования к используемым ресурсам

*Вычислительные ресурсы*: процессор минимум 1 ядро, рекомендуется 2+ ядра для production; память минимум 512 МБ, рекомендуется 1-2 ГБ; диск зависит от объема данных, минимум 10 ГБ для development.

*Внешние зависимости*: PostgreSQL 15+ для хранения данных; Apache Kafka для потребления событий; .NET 9.0 runtime для выполнения приложения; Docker и Docker Compose для контейнеризации.

*Сетевые ресурсы*: порт 5000 для REST API; порт 5433 для подключения к PostgreSQL (в dev режиме); порт для подключения к Kafka (по умолчанию 9092).

\ 
== Сценарии использованияё== Получение количества зарегистрированных пользователей
Администратор отправляет GET запрос на `/api/statistics/registered-users-count` с опциональными параметрами `from` и `to` (в формате ISO 8601) для получения количества зарегистрировавшихся пользователей за указанный временной промежуток. Если параметры не указаны, возвращается общее количество всех зарегистрировавшихся пользователей. Возвращаемое значение — целое число, либо HTTP 400 при некорректном формате дат (дата начала позже даты окончания, будущая дата), либо HTTP 500 при внутренней ошибке сервера.

\
=== Получение уникальных пользователей, просмотревших расписание

Администратор запрашивает количество уникальных пользователей, которые обращались к любому типу расписания (аудиторий, групп или преподавателей) за указанный период. Параметры `from` и `to` опциональны и определяют границы временного интервала анализа. Система подсчитывает для каждого пользователя количество его уникальных запросов к любому типу расписания и возвращает общее количество таких пользователей. Возможные ответы: целое число уникальных пользователей (HTTP 200), ошибка валидации параметров (HTTP 400), ненайденные данные (HTTP 404) или внутренняя ошибка (HTTP 500).

\  
=== Получение уникальных пользователей по типу расписания

Администратор может получить детальную информацию о пользователях в разрезе типов расписания через три отдельных endpoint'а:

*Расписание аудиторий* (`/unique-room-schedule-viewers-count`) — количество пользователей, запрашивавших расписание занятости аудиторий.

*Расписание групп* (`/unique-group-schedule-viewers-count`) — количество пользователей, запрашивавших расписание учебных групп.

*Расписание преподавателей* (`/unique-teacher-schedule-viewers-count`) — количество пользователей, запрашивавших расписание занятости преподавателей.

Для каждого запроса параметры `from` и `to` опциональны. Ответ содержит целое число уникальных пользователей для каждого типа или HTTP 400 при некорректных датах.

\
=== Получение топ N групп по подписчикам

Администратор запрашивает список наиболее популярных учебных групп по количеству уникальных подписчиков на конкретную дату. Параметры запроса включают: `top` (количество групп в топе, значение от 1 до 100, по умолчанию 10) и опциональный `to` (дата, на которую подсчитывать подписчиков, если не указан — текущее состояние). Система для каждого пользователя определяет его последнюю подписку на группу, группирует результаты по названию группы, подсчитывает уникальных подписчиков, сортирует по убыванию количества подписчиков и возвращает топ-N результатов. Ответ — JSON массив объектов с полями `groupName` и `subscribersCount`, либо HTTP 400 если параметр `top` вне диапазона или указана будущая дата.

\
=== Получение топ N групп по просмотрам расписания

Администратор получает рейтинг учебных групп по количеству запросов их расписания за указанный период. Параметры: `top` (1-100, по умолчанию 10) определяет размер топа, `from` и `to` (опциональны) определяют временной интервал анализа. Система агрегирует все запросы расписания по группам, подсчитывает количество запросов для каждой группы, сортирует по убыванию и возвращает топ-N группы. Ответ — JSON массив объектов с названием группы и количеством запросов, либо HTTP 400 при некорректных параметрах (top вне диапазона, дата начала позже окончания, будущая дата).

\ 
=== Получение общего количества запросов расписания групп

Администратор запрашивает суммарное количество всех запросов на просмотр расписания групп за указанный период. Параметры `from` и `to` опциональны и определяют границы анализа. Если параметры не указаны, возвращается общее количество всех запросов расписания групп в системе. Ответ — целое число запросов, либо HTTP 400 при некорректных датах, либо HTTP 404 если данные не найдены.

\
=== Получение статистики по кастомным настройкам пользователей

Администратор может получить текущее состояние использования кастомных и дефолтных настроек пользователями на определенную дату:

*Пользователи с кастомными настройками* (`/users-with-custom-settings-count`) — количество пользователей, активно использующих персонализированные настройки системы на указанную дату.

*Пользователи с дефолтными настройками* (`/users-with-default-settings-count`) — количество пользователей, использующих стандартную конфигурацию настроек на указанную дату.

Параметр `to` опционален (если не указан, используется текущее время). Система определяет для каждого пользователя его последний тип настроек (кастомные или дефолтные) на дату `to` и подсчитывает количество. Ответ — целое число пользователей, либо HTTP 400 при указании будущей даты.

\
=== Получение количества пользователей, изменявших настройки

Администратор запрашивает количество уникальных пользователей, которые выполняли операции по изменению кастомных настроек за указанный период. Эндпоинт `/users-who-set-custom-settings-count` принимает опциональные параметры `from` и `to` для определения временного интервала. Система подсчитывает каждого пользователя только один раз, даже если он несколько раз менял настройки. Ответ — целое число уникальных пользователей, либо HTTP 400 при некорректных датах, либо HTTP 404 если данные не найдены.

\
=== Получение статистики по поисковым запросам

Администратор может получить детальную информацию о поисковой активности через два endpoint'а:

*Количество уникальных пользователей, выполнявших поиск* (`/unique-users-who-searched-count`) — определяет количество уникальных пользователей, которые использовали поисковую функциональность за указанный период.

*Общее количество поисковых запросов* (`/search-requests-count`) — подсчитывает суммарное количество всех поисковых операций, выполненных в системе.

Для обоих запросов параметры `from` и `to` опциональны. Ответ содержит целое число (пользователей или запросов в зависимости от endpoint'а), либо HTTP 400 при некорректных датах, либо HTTP 404 если данные отсутствуют.

#pagebreak()

= Проектирование структуры программы
== Архитектурные слои микросервиса
=== Domain Layer 
Содержит доменные модели, которые независимы от деталей реализации и внешних зависимостей. На данном уровне определяются бизнес-правила и инварианты. Доменные сущности и перечисления отражают ключевые понятия предметной области, формируют устойчивые контракты и не зависят от технологий хранения данных или транспорта. Здесь фиксируются инварианты (например, корректность временных меток, допустимые значения перечислений), вводятся value-объекты и соглашения, повышающие выразительность модели. Благодаря отсутствию инфраструктурных зависимостей, доменный слой легко покрывается модульными тестами и служит опорой для эволюции системы.

\
=== Application Layer
Содержит бизнес-логику приложения, включая use cases, команды, запросы (queries), валидаторы и потребителей Kafka. Использует паттерн MediatR для управления командами и запросами. Слой реализует принципы CQRS: команды изменяют состояние, а запросы предназначены для чтения и агрегирования данных. Обработчики (handlers) оркестрируют сценарии, применяют валидаторы параметров, обеспечивают идемпотентность и устойчивость к повторной доставке событий. Интеграция с брокером сообщений и внешними источниками выполняется через абстракции, что упрощает тестирование и замену провайдеров.

\
=== Infrastructure Layer
Реализует интерфейсы репозиториев, работу с БД через Entity Framework Core, миграции и конфигурацию EF. Здесь определяются сопоставления сущностей (mapping), индексы и ограничения, настраиваются политики транзакций и повторных попыток (connection resiliency). Репозитории предоставляют типовые операции доступа к данным, а миграции позволяют эволюционировать схему без потери целостности. Инфраструктурные компоненты изолированы за контрактами, что дает возможность использовать in-memory хранилище для тестов и переключать СУБД при необходимости.

\
=== API Layer
Содержит REST контроллеры, конфигурацию Swagger/OpenAPI и middleware для обработки HTTP запросов. Контроллеры выступают тонкими адаптерами: принимают параметры HTTP, формируют команды/запросы и делегируют выполнение в Application слой через MediatR. Документация генерируется автоматически на основе аннотаций и XML-комментариев, а единый middleware преобразует исключения в согласованные HTTP коды и JSON ответы. Слой предусматривает поддержку версионирования API и механизмов авторизации при необходимости, оставаясь свободным от бизнес-логики.
#pagebreak()

\ 
== Взаимосвязь уровней компонентов
=== Уровень потребления событий (Kafka Consumers)
Поток данных в систему начинается с асинхронных потребителей событий, подписанных на топики Apache Kafka. Компоненты UserPerformedRequestConsumer и UserUpdatedMessageConsumer непрерывно прослушивают соответствующие топики suai.user-performed-request и suai.user-updated-message. При поступлении нового события потребитель десериализует сообщение в строго типизированную модель (UserPerformedRequestMessage или UserUpdatedMessage), выполняет базовую валидацию данных и проверяет наличие пользователя в базе данных. Если пользователь отсутствует, система автоматически создает новую запись. Затем потребитель на основе типа события формирует соответствующую команду MediatR и передает её в обработчик.

\
=== Уровень бизнес-логики (MediatR Commands и Queries)
Паттерн MediatR обеспечивает разделение запросов на команды (изменяющие состояние системы) и запросы (только читающие данные). Команды включают GroupScheduleCommand, SubscribeUserToGroupCommand, RegisterUserCommand, SetUserCustomSettingsCommand и другие. Каждая команда инкапсулирует намерение выполнить определенное бизнес-действие с необходимыми параметрами. Запросы (Queries) реализуют паттерн CQRS и включают GetRegisteredUsersCountQuery, GetTopGroupsBySubscribersQuery, GetTopGroupsByRequestsQuery и множество других запросов для получения аналитических данных. Каждая команда и запрос обрабатывается специализированным Handler'ом, содержащим бизнес-логику обработки.

\
=== Уровень обработчиков (Command и Query Handlers)
Обработчики команд отвечают за сохранение событий в базе данных. Например, GroupScheduleCommandHandler проверяет наличие группы в системе, создает её при необходимости с нормализованным названием, формирует сущность RequestEntity и сохраняет её транзакционно через интерфейс IAnalyticsDbContext. Обработчики запросов реализуют сложную аналитическую логику с использованием LINQ запросов. Например, GetTopGroupsBySubscribersQueryHandler извлекает события подписок, фильтрует их по временному диапазону, для каждого пользователя определяет последнюю подписку (чтобы учесть смену группы), группирует результаты по названию группы, подсчитывает уникальных подписчиков, сортирует группы по убыванию количества подписчиков и ограничивает результат параметром top. Все обработчики используют валидаторы DateRangeValidator и NumericParameterValidator для проверки входных параметров перед выполнением операций.

\
=== Уровень доступа к данным (Repository и IAnalyticsDbContext)
Интерфейс IAnalyticsDbContext абстрагирует детали работы с базой данных и предоставляет типизированные DbSet для каждой доменной сущности: Users (пользователи), Groups (группы), Requests (запросы на просмотр расписания), Updates (события обновления пользователей). Этот интерфейс определяет контракт для операций с данными и позволяет легко подменять реализацию для тестирования. Обработчики команд и запросов зависят только от интерфейса, а не от конкретной реализации, что соответствует принципу инверсии зависимостей (Dependency Inversion Principle).

\
=== Уровень персистентности (Entity Framework Core и PostgreSQL)
Класс AnalyticsDbContext наследует DbContext из Entity Framework Core и реализует интерфейс IAnalyticsDbContext. Конфигурация сущностей выполняется через Fluent API в отдельных классах конфигурации (EntityTypeConfiguration), что обеспечивает разделение конфигурационной логики от бизнес-моделей. Миграции базы данных управляются через EF Core Migrations, что позволяет версионировать схему БД и безопасно применять изменения. PostgreSQL выбран в качестве СУБД благодаря поддержке JSONB для хранения сложных структур данных, высокой производительности при аналитических запросах и надежности при высоких нагрузках. Индексы создаются на часто используемых полях (UserId, GroupId, OccuredAt, RequestType, UpdateType) для оптимизации запросов.

\
=== Уровень представления (REST API Controllers)
Класс StatisticsController наследует ControllerBase и предоставляет HTTP endpoints для получения аналитических данных. Каждый метод контроллера принимает параметры из HTTP запроса (query string или route parameters), создает соответствующий Query объект MediatR, отправляет его через IMediator.Send() и возвращает результат в формате JSON. Контроллер не содержит бизнес-логики — он выполняет роль тонкого адаптера между HTTP протоколом и внутренней архитектурой приложения. Swagger/OpenAPI автоматически генерирует документацию API на основе аннотаций и XML-комментариев, предоставляя интерактивный интерфейс для тестирования endpoints.

\
=== Обработка ошибок и валидация
Глобальный middleware ExceptionHandlingMiddleware перехватывает все исключения, возникающие в процессе обработки запроса, преобразует их в соответствующие HTTP статус-коды (400 для невалидных параметров, 404 для ненайденных ресурсов, 409 для конфликтов, 500 для внутренних ошибок) и формирует унифицированный JSON ответ с полями status и detail. Валидаторы DateRangeValidator и NumericParameterValidator выбрасывают типизированные исключения InvalidDateRangeException и InvalidParameterException с подробными сообщениями об ошибках, что обеспечивает информативную обратную связь для клиентов API.

\
== Преимущества архитектуры
Данная организация компонентов обеспечивает четкое разделение ответственности между слоями, упрощает тестирование за счет внедрения зависимостей через интерфейсы, позволяет независимо масштабировать компоненты обработки событий и обслуживания HTTP запросов, облегчает поддержку и расширение системы благодаря слабой связанности модулей, и гарантирует соответствие принципам SOLID и Clean Architecture.

\
= Разработка и отладка  программы
== REST API эндпоинты
=== Эндпоинт получения количества зарегистрированных пользователей
На рисунке @fig-registered-users-request представлена структура запроса к эндпоинту `/registered-users-count`, который позволяет получить количество пользователей, зарегистрировавшихся за указанный временной промежуток. Эндпоинт принимает опциональные параметры `from` и `to` типа `DateTimeOffset` для определения границ периода анализа.

#figure(
  image("images/registered-users-count-1.png", width: 100%),
  caption: [Структура запроса к эндпоинту получения количества зарегистрированных пользователей]
) <fig-registered-users-request>

На рисунке @fig-registered-users-response показан пример успешного ответа от эндпоинта с возвращаемым значением типа `integer`, представляющим общее количество зарегистрировавшихся пользователей за заданный период.

#figure(
  image("images/registered-users-count-2.png", width: 100%),
  caption: [Пример ответа эндпоинта получения количества зарегистрированных пользователей]
) <fig-registered-users-response>

\
=== Эндпоинт получения количества уникальных пользователей, просмотревших расписание 
На рисунке @fig-unique-schedule-viewers-request представлена структура запроса к эндпоинту `/unique-schedule-viewers-count`, предназначенному для определения количества уникальных пользователей, которые обращались к любому типу расписания за указанный временной промежуток.

#figure(
  image("images/unique-schedule-viewers-count.png", width: 100%),
  caption: [Структура запроса к эндпоинту получения количества уникальных пользователей, просмотревших расписание]
) <fig-unique-schedule-viewers-request>

На рисунке @fig-unique-schedule-viewers-response показан результат выполнения запроса, содержащий целочисленное значение количества уникальных пользователей, воспользовавшихся функциональностью просмотра расписания.

#figure(
  image("images/unique-schedule-viewers-count-2.png", width: 100%),
  caption: [Пример ответа эндпоинта получения количества уникальных пользователей, просмотревших расписание]
) <fig-unique-schedule-viewers-response>

\
=== Эндпоинт получения количества пользователей, просмотревших расписание аудиторий
На рисунке @fig-unique-room-viewers-request представлена структура запроса к эндпоинту `/unique-room-schedule-viewers-count`, обеспечивающему получение статистики по количеству уникальных пользователей, запрашивавших расписание занятости аудиторий.

#figure(
  image("images/unique-room-schedule-viewers-count-1.png", width: 100%),
  caption: [Структура запроса к эндпоинту получения количества пользователей, просмотревших расписание аудиторий]
) <fig-unique-room-viewers-request>

На рисунке @fig-unique-room-viewers-response показан пример ответа эндпоинта с числовым значением, отражающим количество уникальных пользователей, обратившихся к расписанию аудиторий за указанный период.

#figure(
  image("images/unique-room-schedule-viewers-count-2.png", width: 100%),
  caption: [Пример ответа эндпоинта получения количества пользователей, просмотревших расписание аудиторий]
) <fig-unique-room-viewers-response>

\
=== Эндпоинт получения количества пользователей, просмотревших расписание групп
На рисунке @fig-unique-group-viewers-request представлена структура запроса к эндпоинту `/unique-group-schedule-viewers-count`, предназначенному для определения количества уникальных пользователей, запрашивавших расписание учебных групп.

#figure(
  image("images/unique-group-schedule-viewers-count-1.png", width: 100%),
  caption: [Структура запроса к эндпоинту получения количества пользователей, просмотревших расписание групп]
) <fig-unique-group-viewers-request>

На рисунке @fig-unique-group-viewers-response показан результат выполнения запроса, содержащий целочисленное значение количества уникальных пользователей, воспользовавшихся функцией просмотра расписания групп.

#figure(
  image("images/unique-group-schedule-viewers-count-2.png", width: 100%),
  caption: [Пример ответа эндпоинта получения количества пользователей, просмотревших расписание групп]
) <fig-unique-group-viewers-response>

\
=== Эндпоинт получения количества пользователей, просмотревших расписание преподавателей
На рисунке @fig-unique-teacher-viewers-request представлена структура запроса к эндпоинту `/unique-teacher-schedule-viewers-count`, обеспечивающему получение статистики по количеству уникальных пользователей, просматривавших расписание занятий преподавателей.

#figure(
  image("images/unique-teacher-schedule-viewers-count-1.png", width: 100%),
  caption: [Структура запроса к эндпоинту получения количества пользователей, просмотревших расписание преподавателей]
) <fig-unique-teacher-viewers-request>

На рисунке @fig-unique-teacher-viewers-response показан пример успешного ответа эндпоинта с числовым значением, представляющим количество уникальных пользователей, обратившихся к расписанию преподавателей за заданный временной интервал.

#figure(
  image("images/unique-teacher-schedule-viewers-count-2.png", width: 100%),
  caption: [Пример ответа эндпоинта получения количества пользователей, просмотревших расписание преподавателей]
) <fig-unique-teacher-viewers-response>

\
=== Эндпоинт получения топ групп по количеству подписчиков
На рисунке @fig-top-groups-subscribers-request представлена структура запроса к эндпоинту `/top-groups-by-subscribers`, предназначенному для получения рейтинга наиболее популярных учебных групп по количеству уникальных подписчиков. Эндпоинт принимает параметр `top` для определения размера выборки (от 1 до 100) и опциональный параметр `to` для указания конечной даты анализа.

#figure(
  image("images/top-groups-by-subscribers-1.png", width: 100%),
  caption: [Структура запроса к эндпоинту получения топ групп по количеству подписчиков]
) <fig-top-groups-subscribers-request>

На рисунке @fig-top-groups-subscribers-response показан пример ответа эндпоинта, содержащий массив объектов с информацией о названии группы и количестве её подписчиков, упорядоченный по убыванию количества подписчиков.

#figure(
  image("images/top-groups-by-subscribers-2.png", width: 100%),
  caption: [Пример ответа эндпоинта получения топ групп по количеству подписчиков]
) <fig-top-groups-subscribers-response>

\
=== Эндпоинт получения топ групп по количеству запросов расписания
На рисунке @fig-top-groups-requests-request представлена структура запроса к эндпоинту `/top-groups-by-requests`, обеспечивающему получение рейтинга учебных групп по количеству запросов их расписания за указанный период. Эндпоинт принимает параметр `top` для определения размера выборки и опциональные параметры `from` и `to` для временных границ анализа.

#figure(
  image("images/top-groups-by-requests-1.png", width: 100%),
  caption: [Структура запроса к эндпоинту получения топ групп по количеству запросов расписания]
) <fig-top-groups-requests-request>

На рисунке @fig-top-groups-requests-response показан результат выполнения запроса, представляющий собой массив объектов с данными о названии группы и количестве запросов её расписания, отсортированный в порядке убывания популярности.

#figure(
  image("images/top-groups-by-requests-2.png", width: 100%),
  caption: [Пример ответа эндпоинта получения топ групп по количеству запросов расписания]
) <fig-top-groups-requests-response>

\
=== Эндпоинт получения общего количества запросов расписания групп
На рисунке @fig-group-schedule-count-request представлена структура запроса к эндпоинту `/group-schedule-requests-count`, предназначенному для определения общего количества всех запросов расписания учебных групп за заданный временной промежуток.

#figure(
  image("images/group-schedule-requests-count-1.png", width: 100%),
  caption: [Структура запроса к эндпоинту получения общего количества запросов расписания групп]
) <fig-group-schedule-count-request>

На рисунке @fig-group-schedule-count-response показан пример ответа эндпоинта с целочисленным значением, отражающим суммарное количество запросов к расписанию групп за указанный период.

#figure(
  image("images/group-schedule-requests-count-2.png", width: 100%),
  caption: [Пример ответа эндпоинта получения общего количества запросов расписания групп]
) <fig-group-schedule-count-response>

\
=== Эндпоинт получения количества пользователей с кастомными настройками
На рисунке @fig-custom-settings-request представлена структура запроса к эндпоинту `/users-with-custom-settings-count`, обеспечивающему получение текущего количества пользователей, использующих персонализированные настройки системы на указанную дату.

#figure(
  image("images/users-with-custom-settings-count-1.png", width: 100%),
  caption: [Структура запроса к эндпоинту получения количества пользователей с кастомными настройками]
) <fig-custom-settings-request>

На рисунке @fig-custom-settings-response показан результат выполнения запроса, содержащий числовое значение количества пользователей, активно применяющих персонализированные настройки на момент запроса.

#figure(
  image("images/users-with-custom-settings-count-2.png", width: 100%),
  caption: [Пример ответа эндпоинта получения количества пользователей с кастомными настройками]
) <fig-custom-settings-response>

\
=== Эндпоинт получения количества пользователей с настройками по умолчанию
На рисунке @fig-default-settings-request представлена структура запроса к эндпоинту `/users-with-default-settings-count`, предназначенному для определения текущего количества пользователей, использующих стандартные настройки системы.

#figure(
  image("images/users-with-default-settings-count-1.png", width: 100%),
  caption: [Структура запроса к эндпоинту получения количества пользователей с настройками по умолчанию]
) <fig-default-settings-request>

На рисунке @fig-default-settings-response показан пример ответа эндпоинта с целочисленным значением, отражающим количество пользователей, применяющих стандартную конфигурацию настроек на указанную дату.

#figure(
  image("images/users-with-default-settings-count-2.png", width: 100%),
  caption: [Пример ответа эндпоинта получения количества пользователей с настройками по умолчанию]
) <fig-default-settings-response>

\
=== Эндпоинт получения количества пользователей, изменявших настройки
На рисунке @fig-set-custom-settings-request представлена структура запроса к эндпоинту `/users-who-set-custom-settings-count`, обеспечивающему получение статистики по количеству уникальных пользователей, выполнявших операции по настройке персонализированных параметров системы за указанный временной период.

#figure(
  image("images/users-who-set-custom-settings-count-1.png", width: 100%),
  caption: [Структура запроса к эндпоинту получения количества пользователей, изменявших настройки]
) <fig-set-custom-settings-request>

На рисунке @fig-set-custom-settings-response показан результат выполнения запроса, содержащий числовое значение количества уникальных пользователей, осуществлявших изменение настроек в заданном временном интервале.

#figure(
  image("images/users-who-set-custom-settings-count-2.png", width: 100%),
  caption: [Пример ответа эндпоинта получения количества пользователей, изменявших настройки]
) <fig-set-custom-settings-response>

\
=== Эндпоинт получения количества пользователей, выполнявших поиск
На рисунке @fig-users-searched-request представлена структура запроса к эндпоинту `/unique-users-who-searched-count`, предназначенному для определения количества уникальных пользователей, использовавших функциональность поиска за указанный временной промежуток.

#figure(
  image("images/unique-users-who-searched-count-1.png", width: 100%),
  caption: [Структура запроса к эндпоинту получения количества пользователей, выполнявших поиск]
) <fig-users-searched-request>

На рисунке @fig-users-searched-response показан пример ответа эндпоинта с целочисленным значением, представляющим количество уникальных пользователей, обратившихся к поисковой функциональности системы.

#figure(
  image("images/unique-users-who-searched-count-2.png", width: 100%),
  caption: [Пример ответа эндпоинта получения количества пользователей, выполнявших поиск]
) <fig-users-searched-response>

\ 
=== Эндпоинт получения общего количества поисковых запросов
На рисунке @fig-search-count-request представлена структура запроса к эндпоинту `/search-requests-count`, обеспечивающему получение суммарного количества всех поисковых операций, выполненных в системе за заданный период времени.

#figure(
  image("images/search-requests-count-1.png", width: 100%),
  caption: [Структура запроса к эндпоинту получения общего количества поисковых запросов]
) <fig-search-count-request>

На рисунке @fig-search-count-response показан результат выполнения запроса, содержащий числовое значение общего количества поисковых запросов, зарегистрированных системой за указанный временной интервал.

#figure(
  image("images/search-requests-count-2.png", width: 100%),
  caption: [Пример ответа эндпоинта получения общего количества поисковых запросов]
) <fig-search-count-response>

\
== Описание данных и структур данных
=== Словарь данных

Словарь данных представляет все основные параметры и переменные, используемые в системе. В таблице @tbl-data-dictionary приведено описание типов данных, доменных значений и ограничений для каждого элемента данных микросервиса.

#figure(
  long-table(
    columns: (1.6fr, 2fr, 2fr, 1.5fr),
    align: (left, left, left, center),
    inset: 6pt,
    [*Поле*], [*Тип*], [*Описание*], [*Ограничения*],
    [TelegramUserId], [long], [Идентификатор пользователя в Telegram], [> 0, уникально],
    [OccuredAt], [DateTimeOffset], [Временная метка события], [не в будущем],
    [GroupName], [string], [Название академической группы], [опционально],
    [RequestType], [enum], [Search, RoomSchedule, GroupSchedule, TeacherSchedule], [не null],
    [UpdateType], [enum], [Registered, SubscribedToGroup, SetDefaultSettings, SetCustomSettings], [не null],
    [SubscriptionGroup
    Name], [string?], [Название подписанной группы], [опционально],
    [From], [DateTimeOffset?], [Начало периода фильтрации], [опционально],
    [To], [DateTimeOffset?], [Конец периода фильтрации], [From <= To],
  ),
  caption: "Словарь данных",
  kind: table
)<tbl-data-dictionary>

\ 
=== Описание файлов и хранилища

*PostgreSQL база данных* содержит следующие таблицы: 

`users` (хранит информацию о пользователях); 

`groups` (хранит информацию о группах); 

`requests` (хранит запросы пользователей); 

`updates` (хранит события обновления); 

`__EFMigrationsHistory` (служебная таблица EF Core для отслеживания миграций).


На рисунке @fig-db-er-diagram показана ER-диаграмма базы данных микросервиса SuaiScheduleBotAnalytics, демонстрирующая основные таблицы и связи между ними.

#figure(
  image("images/db-er-diagram.png", width: 90%),
  caption: [ER-диаграмма базы данных микросервиса SuaiScheduleBotAnalytics],
  kind: image
) <fig-db-er-diagram>

#pagebreak()
=== Основные доменные сущности

В таблице @table-domain-entities представлены основные доменные сущности микросервиса с их свойствами и назначением в системе, включая типы данных и семантику каждого атрибута.

#figure(
  long-table(
    columns: (auto, auto, auto, auto, auto),
    align: (horizon, horizon, left, left, left),
    inset: 6pt,
    [*Сущность*], [*Описание*], [*Свойство*], [*Тип*], [*Комментарий*],
    table.cell(rowspan: 6)[UserEntity],
    table.cell(rowspan: 6)[Представляет пользователя системы],
    [Id], [long], [Первичный ключ, автоинкрементируемое целое число],
    [TelegramId], [long], [Уникальный идентификатор в Telegram],
    [RegisteredAt], [DateTimeOffset], [Дата и время регистрации],
    [FavoriteGroup
    Id], [long?], [ID группы, на которую подписан пользователь],
    [Requests], [List<RequestEntity>], [Навигационное свойство запросов пользователя],
    [Updates], [List<UpdateEntity>], [Навигационное свойство событий обновления пользователя],
    table.cell(rowspan: 5)[GroupEntity],
    table.cell(rowspan: 5)[Представляет академическую группу],
    [Id], [long], [Первичный ключ],
    [Name], [string], [Название группы (например, "М411")],
    [Users], [List<UserEntity>], [Навигационное свойство подписанных пользователей],
    [Requests], [List<RequestEntity>], [Навигационное свойство запросов расписания],
    [Updates], [List<UpdateEntity>], [Навигационное свойство событий обновления группы],
    table.cell(rowspan: 5)[RequestEntity],
    table.cell(rowspan: 5)[Представляет действие пользователя при просмотре расписания],
    [Id], [long], [Первичный ключ],
    [RequestType], [UserRequestTypes], [Тип запроса (enum: ViewSchedule, ViewClassroom и т.д.)],
    [OccuredAt], [DateTimeOffset], [Временная метка события],
    [UserId], [long?], [ID пользователя, выполнившего запрос],
    [GroupId], [long?], [ID группы, по которой выполнен запрос],
    table.cell(rowspan: 5)[UpdateEntity],
    table.cell(rowspan: 5)[Представляет событие обновления информации пользователя],
    [Id], [long], [Первичный ключ],
    [UpdateType], [UserUpdateTypes], [Тип события (enum: Registered, SubscribedToGroup и т.д.)],
    [OccuredAt], [DateTimeOffset], [Временная метка события],
    [UserId], [long?], [ID пользователя],
    [GroupId], [long?], [ID связанной группы],
    table.cell(rowspan: 3)[BaseEntity],
    table.cell(rowspan: 3)[Базовый класс для всех сущностей],
    [Id], [long], [Первичный ключ],
    [CreatedAt], [DateTimeOffset], [Время создания],
    [UpdatedAt], [DateTimeOffset], [Время последнего обновления],
  ),
  caption: "Основные доменные сущности системы",
  kind: table
)<table-domain-entities>

\
== Разработка алгоритмов
=== Алгоритм обработки подписки на группу

На рисунке @lst-command-subscribe-algorithm представлена блок-схема алгоритма выполнения команды SubscribeUserToGroupCommand. Алгоритм создаёт группу при отсутствии и сохраняет событие подписки пользователя в базу данных.

#figure(
  image("images/lst-command-subscribe-algorithm.png", height: 70%),
  caption: [Блок-схема алгоритма обработки команды подписки пользователя на группу]
) <lst-command-subscribe-algorithm>

\ 
=== Алгоритм получения статистики зарегистрированных пользователей

На рисунке @lst-query-registered-users-algorithm представлена блок-схема алгоритма обработки запроса GetRegisteredUsersCountQuery. Алгоритм выполняет валидацию временного диапазона, извлекает события регистрации и подсчитывает количество уникальных пользователей, зарегистрировавшихся в заданный период.

#figure(
  image("images/lst-query-registered-users-algorithm.png", height: 70%),
  caption: [Блок-схема алгоритма получения количества зарегистрированных пользователей за период]
) <lst-query-registered-users-algorithm>

\
=== Алгоритм получения топ N групп по количеству запросов

На рисунке @lst-query-top-groups-requests-algorithm представлена блок-схема алгоритма обработки запроса GetTopGroupsByRequestsQuery. Алгоритм выполняет валидацию входных параметров, извлекает запросы расписания групп за указанный период, группирует их и возвращает рейтинг наиболее часто запрашиваемых групп.

#figure(
  image("images/lst-query-top-groups-requests-algorithm.png", height: 75%),
  caption: [Блок-схема алгоритма получения топ групп по количеству запросов расписания за период]
) <lst-query-top-groups-requests-algorithm>

\
=== Алгоритм потребления событий запросов пользователей

В листинге @lst-consumer-request-algorithm приведён псевдокод алгоритма асинхронной обработки событий запросов пользователей в потребителе UserPerformedRequestConsumer.

#figure(```SQL
АЛГОРИТМ Потребление событий запросов пользователей
ВХОД: Сообщение из suai.user-performed-request
ВЫХОД: Запись в БД или ошибка

НАЧАЛО
  ПОКА есть сообщение
    Извлечь идентификатор_пользователя, тип_запроса, название_группы
    Найти пользователя; при отсутствии создать и сохранить
    Зафиксировать событие
    ВЫБОР тип_запроса
      Search -> подготовить команду поиска
      RoomSchedule -> подготовить команду расписания аудиторий
      GroupSchedule -> ЕСЛИ указана группа ТО команда расписания группы ИНАЧЕ ошибка отсутствия группы
      TeacherSchedule -> подготовить команду расписания преподавателя
      ИНАЧЕ -> ошибка неизвестного типа
    КОНЕЦ ВЫБОР
    Передать команду в обработчик с повторными попытками
    ЕСЛИ обработка успешна ТО сохранить результат ИНАЧЕ отправить в очередь ошибок
  КОНЕЦ ПОКА
КОНЕЦ
```,
  caption: [Алгоритм асинхронной обработки событий запросов пользователей]
) <lst-consumer-request-algorithm>

\
=== Алгоритм обработки запроса расписания группы

В листинге @lst-command-group-schedule-algorithm представлен псевдокод алгоритма обработки команды GroupScheduleCommand. Алгоритм сохраняет запрос пользователя и создаёт группу при необходимости.

#figure(```
АЛГОРИТМ Обработка команды запроса расписания группы
ВХОД: Команда с идентификатором пользователя, названием группы и временной меткой
ВЫХОД: Сохранённая в БД запись о запросе

НАЧАЛО
  Проверить наличие пользователя; при отсутствии ошибка "пользователь не найден"
  Найти группу; при отсутствии создать с нормализованным названием и сохранить
  Создать запись запроса расписания группы
  Сохранить запись транзакционно и вывести
КОНЕЦ
```,
  caption: [Алгоритм обработки команды запроса расписания группы]
) <lst-command-group-schedule-algorithm>

\
=== Алгоритм потребления событий обновлений пользователей

В листинге @lst-consumer-update-algorithm приведён псевдокод алгоритма асинхронной обработки событий об обновлении пользователя в потребителе UserUpdatedMessageConsumer.

#figure(```
АЛГОРИТМ Потребление событий обновлений пользователей
ВХОД: Сообщение из suai.user-updated-message
ВЫХОД: Сохранённые данные в БД и обработанная команда

НАЧАЛО
  ПОКА есть сообщение
    Извлечь идентификатор_пользователя, тип_обновления, название_группы
    Найти пользователя; при отсутствии создать и сохранить
    ВЫБОР тип_обновления
      Registered -> подготовить команду регистрации
      SubscribedToGroup -> ЕСЛИ указана группа ТО команда подписки ИНАЧЕ ошибка отсутствия группы
      SetDefaultSettings -> команда стандартных настроек
      SetCustomSettings -> команда пользовательских настроек
      ИНАЧЕ -> ошибка неизвестного типа
    КОНЕЦ ВЫБОР
    Передать команду в обработчик, сохранить изменения и залогировать событие
  КОНЕЦ ПОКА
КОНЕЦ
```,
  caption: [Алгоритм асинхронной обработки событий обновлений пользователей]
) <lst-consumer-update-algorithm>

\
=== Алгоритм получения топ групп по уникальным подписчикам

В листинге @lst-query-top-groups-subscribers-algorithm приведён псевдокод алгоритма обработки запроса GetTopGroupsBySubscribersQuery. Алгоритм определяет наиболее популярные группы по количеству уникальных подписчиков.

#figure(```
АЛГОРИТМ Получение топ групп по количеству уникальных подписчиков
ВХОД: Количество групп в топе, дата среза
ВЫХОД: Список групп с количеством подписчиков

НАЧАЛО
  ВВОД top, дата_среза
  ЕСЛИ top < 1 ИЛИ top > 100 ТО ошибка "top вне диапазона"
  ЕСЛИ дата_среза в будущем ТО ошибка "дата в будущем"
  Извлечь события подписки до даты_среза
  Отсортировать по времени, взять последнее событие на пользователя
  Сгруппировать по группе, подсчитать уникальных, отсортировать
  Взять первые top групп и вывести
КОНЕЦ
```,
  caption: [Алгоритм получения топ групп по количеству уникальных подписчиков]
) <lst-query-top-groups-subscribers-algorithm> 

\
=== Алгоритм получения количества пользователей с настройками

В листинге @lst-query-user-settings-algorithm представлен псевдокод алгоритма обработки запроса GetUsersWithCustomSettingsCountQuery. Алгоритм определяет количество пользователей с кастомными настройками на указанную дату.

#figure(```
АЛГОРИТМ Получение количества пользователей с кастомными настройками
ВХОД: Дата среза
ВЫХОД: Количество пользователей с пользовательскими настройками

НАЧАЛО
  ВВОД дата_среза
  ЕСЛИ дата_среза в будущем ТО ошибка "дата в будущем"
  Извлечь события изменения настроек до даты_среза
  Отсортировать по времени, для каждого пользователя взять последнее событие
  Оставить тип "пользовательские настройки", подсчитать пользователей, вывести
  ПРИМЕЧАНИЕ: для стандартных настроек применить тот же порядок с другим типом события
КОНЕЦ
```,
  caption: [Алгоритм получения количества пользователей с кастомными настройками]
) <lst-query-user-settings-algorithm>

\
=== Алгоритм валидации параметров запросов

В листинге @lst-validator-date-range-algorithm приведён псевдокод алгоритма валидации диапазона дат в компоненте DateRangeValidator.

#figure(```
АЛГОРИТМ Валидация диапазона дат
ВХОД: Дата начала, дата окончания
ВЫХОД: Ошибка при нарушении правил или успешное завершение

НАЧАЛО
  ВВОД дата_начала, дата_окончания
  ЕСЛИ обе даты заданы И дата_начала > дата_окончания ТО ошибка "некорректный диапазон"
  ЕСЛИ дата_начала задана И дата_начала в будущем ТО ошибка "дата начала в будущем"
  ЕСЛИ дата_окончания задана И дата_окончания в будущем ТО ошибка "дата окончания в будущем"
КОНЕЦ
```,
  caption: [Алгоритм валидации диапазона дат]
) <lst-validator-date-range-algorithm>

В листинге @lst-validator-numeric-algorithm представлен псевдокод алгоритма валидации числовых параметров в компоненте NumericParameterValidator.

#figure(```
АЛГОРИТМ Валидация числовых параметров
ВХОД: Числовое значение, минимально допустимое значение, максимально допустимое значение
ВЫХОД: Ошибка при нарушении границ или успешное завершение

НАЧАЛО
  ВВОД значение, минимум, максимум
  ЕСЛИ значение < минимум ИЛИ значение > максимум ТО ошибка "значение вне диапазона"
КОНЕЦ
```,
  caption: [Алгоритм валидации числовых параметров]
) <lst-validator-numeric-algorithm>

#pagebreak()

== Реализация и отладка программы
=== Конвенция именования

*Переменные* -- для локальных переменных и параметров используется стиль camelCase (примеры: userId, requestCount, groupName). Для public свойств классов применяется стиль PascalCase (примеры: TelegramId, RegisteredAt, FavoriteGroup). Private поля имеют префикс подчеркивания (примеры: \_logger, \_mediator, \_dbContext).

*Функции и методы* -- все публичные методы именуются в стиле PascalCase с глаголами в названии, такими как Get, Set, Create, Update, Delete, Process (примеры: GetRegisteredUsersCount(), Consume()).

*Классы и типы* -- все классы, интерфейсы и перечисления используют стиль PascalCase. Доменные модели имеют суффикс Entity (примеры: UserEntity, GroupEntity). Kafka потребители имеют суффикс Consumer (примеры: UserPerformedRequestConsumer). MediatR объекты имеют суффиксы Query, Command, Handler. REST контроллеры имеют суффикс Controller. Интерфейсы имеют префикс I (пример: IAnalyticsDbContext).

*Модули и пространства имен* -- структурированы по архитектурным слоям (Application, Domain, Infrastructure) с дополнительными папками для группировки логики (Kafka, Commands, Queries, Persistence).

\
=== Стиль оформления кода

Отступы в коде составляют 4 пробела (стандарт .NET). Комментирование включает XML документацию для public методов, inline комментарии для сложной логики, TODO комментарии для будущих улучшений, при этом самоочевидный код не комментируется. Разбиение на файлы предусматривает один класс в одном файле, вспомогательные классы могут находиться в одном файле, размер файла не превышает 300 строк.

\
=== Описание модулей

*SuaiScheduleBotAnalytics.Domain* содержит базовый класс BaseEntity, используемый всеми доменными сущностями. На этом слое отсутствует бизнес-логика, поэтому модуль остается независимым от деталей реализации.

*SuaiScheduleBotAnalytics.Application* является основным слоем бизнес-логики. Включает Kafka потребителей для обработки событий из очереди сообщений, MediatR команды и запросы для операций с данными, валидаторы входных данных с использованием FluentValidation, и интерфейсы для определения контрактов компонентов.

*SuaiScheduleBotAnalytics.DataLayer.EF* реализует слой доступа к данным. Содержит AnalyticsDbContext для конфигурации Entity Framework Core, конфигурацию сущностей через entity configurations, миграции баз данных, и реализацию репозиториев для работы с хранилищем.

*SuaiScheduleBotAnalytics.WebApi* содержит API слой приложения. Включает Program.cs с конфигурацией DI контейнера для внедрения зависимостей, StatisticsController с REST endpoints для получения аналитики, middleware для глобальной обработки ошибок (где требуется), и конфигурацию Swagger для документации API.

\
=== Описание основных функций и методов

В таблице @tbl-functions описаны основные функции и методы микросервиса, включая их сигнатуры, входные и выходные параметры, а также предназначение в системе аналитики.

#figure(
  long-table(
    columns: (1.2fr, 1fr, 2fr, 1.5fr, 1.2fr, 1.25fr),
    align: (left, left, left, left, left, left),
    inset: 6pt,
    [*Класс*], [*Имя\ метода,\ функции*], [*Прототип*], [*Назначение*], [*Входные данные*], [*Выходные данные*],
    [User
    Performed
    Request
    Consumer], [Consume], [Task Consume
    (ConsumeContext
    \<UserPerformed
    RequestMessage\> context)], [Обработка события просмотра расписания из Kafka и сохранение в БД], [context], [-],
    [Get
    Registered
    Users
    Count
    Query
    Handler], [Handle], [Task\<int\> Handle
    (GetRegistered
    UsersCountQuery query,
    CancellationToken
    cancellationToken)], [Получение количества зарегистрировавшихся пользователей за период с валидацией диапазона дат], [query, cancellation
    Token], [int],
    [GetGroup
    Schedule
    Requests
    Count
    Query
    Handler], [Handle], [Task\<int\> Handle
    (GetGroup
    Schedule
    RequestsCount
    Query query,
    CancellationToken
    cancellationToken)], [Получение количества запросов на просмотр расписания групп за период], [query, cancellation
    Token], [int],
    [Register
    User
    Command
    Handler], [Handle], [Task Handle
    (RegisterUser
    Command command,
    CancellationToken
    cancellationToken)], [Создание записи события регистрации пользователя в БД], [command, cancellation
    Token
    ], [-],
    [Group
    Schedule
    Command
    Handler], [Handle], [Task Handle
    (GroupSchedule
    Command command,
    CancellationToken
    cancellationToken)], [Добавление записи о запросе расписания группы с созданием группы при необходимости], [command, cancellation
    Token], [-],
    [Search
    Request
    Handler], [Handle], [Task Handle
    (SearchCommand
    command,
    CancellationToken
    cancellationToken)], [Добавление записи о поисковом запросе пользователя в БД], [command, cancellation
    Token], [-],
    [Room
    Schedule
    Command
    Handler], [Handle], [Task Handle
    (RoomSchedule
    Command command,
    CancellationToken
    cancellationToken)], [Добавление записи о запросе расписания аудитории в БД], [command, cancellation
    Token], [-],
    [Teacher
    Schedule
    Command
    Handler], [Handle], [Task Handle
    (TeacherSchedule
    Command command,
    CancellationToken
    cancellationToken)], [Добавление записи о запросе расписания преподавателя в БД], [command, cancellation
    Token], [-],
    [Subscribe
    User
    ToGroup
    Command
    Handler], [Handle], [Task Handle
    (SubscribeUser
    ToGroup
    Command command,
    CancellationToken
    cancellationToken)], [Создание записи события подписки пользователя на группу с созданием группы при необходимости], [command, cancellation
    Token], [-],
    [SetUser
    Custom
    Settings
    Command
    Handler], [Handle], [Task Handle
    (SetUserCustom
    SettingsCommand
    command,
    CancellationToken
    cancellationToken)], [Создание записи события установки пользовательских настроек], [command, cancellation
    Token], [-],
    [GetTop
    GroupsBy
    Subscribers
    Query
    Handler], [Handle], [Task\<List\<Group
    AndSubscribers
    ResponseModel\>\>
    Handle
    (GetTopGroupsBy
    SubscribersQuery
    query,
    CancellationToken
    cancellationToken)], [Получение топ N групп по количеству уникальных подписчиков с валидацией параметров], [query, cancellation
    Token], [List\<Group
    And
    Subscribers
    Response
    Model\>],
    [GetTop
    Groups
    By
    Requests
    Query
    Handler], [Handle], [Task\<List\<Top
    Group
    ByRequests
    ResponseModel\>\> Handle
    (GetTopGroupsBy
    RequestsQuery query,
    CancellationToken
    cancellationToken)], [Получение топ N групп по количеству запросов расписания с валидацией диапазона дат], [query, cancellation
    Token], [List\<Top
    Group
    ByRequests
    Response
    Model\>],
    [Get
    Unique
    Schedule
    Viewers
    Count
    Query
    Handler], [Handle], [Task\<int\> Handle
    (GetUnique
    ScheduleViewers
    CountQuery query,
    CancellationToken
    cancellationToken)], [Получение количества уникальных пользователей, просмотревших расписание (любого типа) за период], [query, cancellation
    Token], [int],
    [Date
    Range
    Validator], [Validate
    Date
    Range], [void ValidateDateRange
    (DateTimeOffset? from,
    DateTimeOffset? to)], [Валидация корректности диапазона дат (from не позже to)], [from, to], [-],
    [Date
    Range
    Validator], [Validate
    Not
    Future], [void ValidateNotFuture
    (DateTimeOffset? date,
    string parameterName)], [Валидация что дата не находится в будущем], [date, parameter
    Name], [-],
    [Numeric
    Parameter
    Validator], [Validate
    Positive
    Integer], [void ValidatePositive
    Integer
    (int value,
    string parameterName,
    int minValue,
    int maxValue)], [Валидация что числовой параметр находится в допустимом диапазоне], [value, parameter
    Name, minValue, maxValue], [-],
  ),
  caption: "Описание основных функций и методов",
  kind: table
)<tbl-functions>

\
=== Оптимизация кода

*Оптимизация производительности* достигается использованием асинхронных операций (async/await) для non-blocking I/O, query splitting в Entity Framework Core для оптимизации запросов с Include(), использованием индексов на часто используемых полях (UserId, GroupId, OccuredAt), кэшированием результатов часто запрашиваемых данных.

*Оптимизация объема кода* включает использование DI контейнера для избежания дублирования логики, применение паттерна медиатор для уменьшения связанности компонентов, использование интерфейсов для абстрагирования реализации.

*Масштабируемость системы* обеспечивается микросервисной архитектурой, которая позволяет масштабировать компоненты независимо. Асинхронная обработка через Kafka позволяет обрабатывать пиковые нагрузки без перегруженности. Stateless дизайн API позволяет горизонтальное масштабирование приложения.

\
=== Средства отладки

Для отладки приложения используются следующие инструменты: Jetbrains Rider для интерактивной отладки приложения с breakpoints и пошаговым выполнением, Jetbrains DataGrip для просмотра и анализа данных в PostgreSQL, Kafka UI для мониторинга топиков Kafka и анализа сообщений в очередях, Application Insights для мониторинга production приложения и сбора телеметрии, structured logging с Serilog для структурированного анализа логов и отслеживания проблем, Swagger UI для тестирования REST API endpoints и проверки контрактов.

#pagebreak()

= Тестирование

== Цели и организация тестирования

Тестирование микросервиса выполнялось с целью проверки корректности реализации всех функциональных требований, определенных в разделе "Разработка требований к программе". Тестовая стратегия включает разработку комплексного набора юнит тестов, которые проверяют изолированную функциональность отдельных компонентов без зависимостей от внешних систем.

Все тестовые сценарии реализованы в виде автоматизированных модульных (юнит) тестов с использованием фреймворка Xunit для .NET. Юнит тесты представляют собой быстрые и независимые проверки отдельных методов и классов, позволяющие разработчикам оперативно выявлять регрессии и ошибки в коде.

*Организация и структура тестирования*: тесты организованы по архитектурным слоям приложения, что позволяет эффективно управлять и поддерживать тестовый код. Для изоляции компонентов используется in-memory база данных Entity Framework Core, что исключает необходимость подключения к реальной PostgreSQL при выполнении тестов и значительно ускоряет их выполнение. Параметризованные тесты (Theory и InlineData) обеспечивают проверку одной функции с множеством различных входных значений, что позволяет повысить эффективность тестового покрытия без дублирования кода.

*Целевые компоненты юнит тестирования*: Query Handlers — проверка логики получения аналитических данных с различными фильтрами; Command Handlers — проверка обработки команд изменения состояния системы; Validators — проверка корректности валидации входных параметров (диапазоны дат, числовые значения); Middleware — проверка преобразования исключений в соответствующие HTTP статус-коды и форматы ответов.

*Методология проведения тестов*: каждый юнит тест следует трехэтапной структуре Arrange-Act-Assert, где на этапе Arrange подготавливается изолированное окружение и тестовые данные, на этапе Act выполняется проверяемая функциональность, и на этапе Assert верифицируются ожидаемые результаты. Все тесты выполняются независимо друг от друга, что гарантирует воспроизводимость результатов и исключает побочные эффекты между тестовыми сценариями.

== Описание тестовых сценариев

Разработана комплексная система тестирования, покрывающая все уровни приложения. В таблице @table-test-technologies представлены основные тестовые классы, организованные по слоям приложения с указанием их назначения и проверяемых функций.

#figure(
  long-table(
    columns: (1.8fr, 1.8fr, 3fr),
    align: (horizon, horizon, left),
    inset: 6pt,
    [*Тестовый класс*], [*Описание*],[*Проверяемая функциональность*],
    table.cell(colspan: 3, align: center)[*Application Layer — Query Handlers (обработчики запросов статистики)*],
    table.cell(rowspan: 4)[GetRegisteredUsers
    CountQueryHandler
    Tests], table.cell(rowspan: 4)[Тестирование подсчета пользователей], [Проверка получения общего количества зарегистрированных пользователей без применения фильтров],
    [Проверка фильтрации по дате начала периода],
    [Проверка фильтрации по дате окончания периода],
    [Проверка фильтрации по диапазону дат с указанием начала и окончания периода],
    table.cell(rowspan: 4)[GetUniqueSchedule
    ViewersCountQuery
    HandlerTests], table.cell(rowspan: 4)[Тестирование уникальных просмотров расписания], [Проверка подсчета уникальных пользователей по всем типам просмотров расписания (аудиторий, групп, преподавателей)],
    [Проверка исключения дубликатов запросов от одного пользователя],
    [Проверка исключения поисковых запросов из статистики],
    [Проверка фильтрации результатов по временным периодам],
    table.cell(rowspan: 3)[GetGroupSchedule
    RequestsCountQuery
    HandlerTests], table.cell(rowspan: 3)[Подсчет просмотров расписания групп], [Проверка подсчета всех запросов на просмотр расписания групп за указанный период],
    [Проверка исключения из подсчета запросов других типов],
    [Проверка корректности применения фильтрации по дате начала и окончания периода],
    table.cell(rowspan: 4)[GetTopGroupsBy
    RequestsQuery
    HandlerTests], table.cell(rowspan: 4)[Получение топ-групп по количеству просмотров], [Проверка корректности сортировки групп по количеству запросов в порядке убывания],
    [Проверка ограничения количества результатов параметром top],
    [Проверка подсчета всех запросов включая повторные от одного пользователя],
    [Проверка корректности работы при наличии нескольких групп],
    table.cell(rowspan: 4)[GetTopGroupsBy
    SubscribersQuery
    HandlerTests], table.cell(rowspan: 4)[Получение топ-групп по количеству подписчиков], [Проверка корректности сортировки групп по количеству уникальных подписчиков в порядке убывания],
    [Проверка ограничения количества результатов параметром top],
    [Проверка исключения повторных подписок одного пользователя],
    [Проверка фильтрации результатов по датам подписок],
    table.cell(rowspan: 4)[ScheduleViewersBy
    TypeQueryHandler
    Tests], table.cell(rowspan: 4)[Статистика просмотров по типам запросов], [Проверка работы запроса получения уникальных пользователей, просмотревших расписание аудиторий],
    [Проверка работы запроса получения уникальных пользователей, просмотревших расписание групп],
    [Проверка работы запроса получения уникальных пользователей, просмотревших расписание преподавателей],
    [Проверка применения фильтрации по временным периодам для всех типов запросов],
    table.cell(rowspan: 6)[UserSettingsQuery
    HandlerTests], table.cell(rowspan: 6)[Статистика по настройкам пользователей], [Проверка работы запроса получения количества пользователей с кастомными настройками],
    [Проверка работы запроса получения количества пользователей с дефолтными настройками],
    [Проверка работы запроса получения количества пользователей, устанавливавших кастомные настройки],
    [Проверка учета только последнего обновления настроек пользователя],
    [Проверка игнорирования событий других типов],
    [Проверка фильтрации результатов по временным периодам],
    table.cell(rowspan: 5)[SearchQueryHandler
    Tests], table.cell(rowspan: 5)[Тестирование функциональности поиска], [Проверка работы запроса получения уникальных пользователей, выполнивших поиск],
    [Проверка подсчета уникальных пользователей без учета повторных поисковых запросов],
    [Проверка исключения дубликатов при подсчете пользователей],
    [Проверка фильтрации результатов по диапазону дат],
    [Проверка исключения из подсчета запросов других типов],
    table.cell(rowspan: 3)[QueryValidationTests], table.cell(rowspan: 3)[Комплексная валидация входных параметров], [Проверка выброса исключения InvalidDateRangeException при указании даты начала позже даты окончания],
    [Проверка выброса исключения InvalidParameterException при указании дат в будущем],
    [Проверка выброса исключения InvalidParameterException при указании значения параметра top вне допустимого диапазона от 1 до 100],
    table.cell(colspan: 3, align: center)[*Application Layer — Validators (валидаторы входных данных)*],
    table.cell(rowspan: 5)[DateRangeValidator
    Tests], table.cell(rowspan: 5)[Валидация диапазонов дат], [Проверка метода ValidateDateRange на корректность валидации условия, что дата начала не может быть позже даты окончания],
    [Проверка метода ValidateNotFuture на корректность валидации условия, что указанная дата не может быть в будущем],
    [Проверка позитивных сценариев с корректным диапазоном дат, равными датами и значениями null],
    [Проверка негативных сценариев с некорректным диапазоном и датами в будущем],
    [Проверка корректности формата сообщений об ошибках с указанием дат в формате ISO],
    table.cell(rowspan: 5)[NumericParameter
    ValidatorTests], table.cell(rowspan: 5)[Валидация числовых параметров], [Проверка метода ValidatePositiveInteger для параметров top, limit, count на соответствие допустимым диапазонам значений],
    [Проверка диапазонов со значениями по умолчанию от 1 до 1000 и специальным диапазоном для параметра top от 1 до 100],
    [Проверка корректности обработки граничных значений (минимум и максимум диапазона)],
    [Проверка возможности задания кастомных диапазонов для различных параметров],
    [Проверка корректности формирования сообщений об ошибках с указанием допустимых границ значений],
    table.cell(colspan: 3, align: center)[*WebApi Layer — Middleware (обработка исключений)*],
    table.cell(rowspan: 9)[ExceptionHandling
    MiddlewareTests], table.cell(rowspan: 9)[Преобразование исключений в HTTP статус-коды], [Проверка преобразования исключений ArgumentNullException, ArgumentException, ArgumentOutOfRangeException, FormatException в HTTP статус-код 400],
    [Проверка преобразования InvalidOperationException в HTTP статус-код 409 (или 404 для исключения с текстом "Sequence contains no elements")],
    [Проверка преобразования KeyNotFoundException в HTTP статус-код 404],
    [Проверка преобразования UnauthorizedAccessException в HTTP статус-код 403],
    [Проверка преобразования OperationCanceledException в HTTP статус-код 499],
    [Проверка преобразования кастомных исключений InvalidDateRangeException, InvalidParameterException, ValidationException в HTTP статус-код 400],
    [Проверка преобразования необработанных исключений в HTTP статус-код 500],
    [Проверка корректности формата ответа application/json с наличием полей status и detail],
    [Проверка отсутствия стек-трейсов в production окружении],
  ),
  caption: "Структура и назначение основных тестовых классов",
  kind: table
)<table-test-scenarios>

== Результаты тестирования

В таблице @tbl-test-results представлены результаты выполнения основных тестовых сценариев. Каждый сценарий проверяет определённый функциональный аспект системы, включая получение статистики, фильтрацию данных, валидацию параметров и обработку ошибок в различных компонентах микросервиса.

#figure(
  long-table(
    columns: (auto, 1fr, 1.5fr, 1.2fr, 0.8fr),
    align: horizon,
    [*№*], [*Название теста*], [*Тестовые данные*], [*Ожидаемый результат*], [*Статус*],
    [1], [Получение общего количества пользователей], [3 пользователя (01.2024, 02.2024, 03.2024), фильтры: from=null, to=null], [Количество: 3], [Успешно выполнен],
    
    [2], [Фильтрация пользователей по дате начала], [3 пользователя, фильтр: from=15.02.2024, to=null], [Количество: 2 (пользователи с 15.02.2024 и позже)], [Успешно выполнен],
    
    [3], [Фильтрация пользователей по дате окончания], [3 пользователя, фильтр: from=null, to=10.02.2024], [Количество: 2 (пользователи до 10.02.2024 включительно)], [Успешно выполнен],
    
    [4], [Подсчет уникальных пользователей], [2 пользователя, 4 запроса (1 пользователь выполнил 3 запроса)], [Количество уникальных: 2], [Успешно выполнен],
    
    [5], [Исключение поисковых запросов из статистики], [2 пользователя: 1 просмотр расписания, 1 поиск], [Количество уникальных: 1 (только просмотры расписания)], [Успешно выполнен],
    
    [6], [Топ групп по количеству просмотров], [3 группы: group-a (4 запроса), group-b (2), group-c (1)], [Список отсортирован: group-a, group-b, group-c с соответствующими счетчиками], [Успешно выполнен],
    
    [7], [Ограничение количества результатов], [5 групп с запросами, параметр top=2], [Возвращается ровно 2 группы], [Успешно выполнен],
    [8], [Валидация: корректный диапазон дат], [from=01.01.2024, to=31.12.2024], [Исключение не выбрасывается], [Успешно выполнен],
    
    [9], [Валидация: равные даты], [from=15.06.2024, to=15.06.2024], [Исключение не выбрасывается (допустимо)], [Успешно выполнен],
    
    [10], [Валидация: обе даты null], [from=null, to=null], [Исключение не выбрасывается (фильтрация отсутствует)], [Успешно выполнен],
    
    [11], [Ошибка: некорректный диапазон дат], [from=31.12.2024, to=01.01.2024], [InvalidDateRange Exception с сообщением "не может быть позже"], [Успешно выполнен],
    
    [12], [Ошибка: дата в будущем], [from=дата через 10 дней от текущей], [InvalidParameter Exception с сообщением "содержит будущую дату"], [Успешно выполнен],
    
    [13], [Валидация числовых параметров: допустимое значение], [top=50, min=1, max=100], [Исключение не выбрасывается], [Успешно выполнен],
    
    [14], [Ошибка: параметр меньше минимума], [top=0, min=1, max=100], [InvalidParameter Exception: "имеет некорректное значение", "Минимально: 1"], [Успешно выполнен],
    
    [15], [Ошибка: параметр больше максимума], [top=101, min=1, max=100], [InvalidParameter Exception: "имеет некорректное значение", "Максимально: 100"], [Успешно выполнен],
    
    [16], [Обработка Argument NullException], [Middleware получает ArgumentNullException], [HTTP 400 + "Некорректные параметры запроса"], [Успешно выполнен],
    
    [17], [Обработка KeyNotFound Exception], [Middleware получает KeyNotFoundException], [HTTP 404 + "Запрашиваемый ресурс не найден"], [Успешно выполнен],
    
    [18], [Обработка Invalid Operation Exception], [Middleware получает InvalidOperationException], [HTTP 409 + "Операция не может быть выполнена"], [Успешно выполнен],
    
    [19], [Обработка неизвестного исключения], [Middleware получает Exception("boom")], [HTTP 500 + "Внутренняя ошибка сервиса"], [Успешно выполнен],
    
    [20], [Обработка InvalidDate Range Exception], [Middleware получает InvalidDateRangeException с описанием диапазона], [HTTP 400, сообщение содержит детали о некорректном диапазоне], [Успешно выполнен],
    
    [21], [Подсчет запросов на просмотр расписания групп], [3 запроса GroupSchedule, 1 RoomSchedule, 1 TeacherSchedule, 1 Search], [Количество: 3 (только GroupSchedule)], [Успешно выполнен],
    
    [22], [Топ групп по подписчикам с уникальностью], [group-a: 3 уникальных подписчика, group-b: 2, group-c: 1], [Список отсортирован: group-a (3), group-b (2), group-c (1)], [Успешно выполнен],
    
    [23], [Повторная подписка одного пользователя], [1 пользователь подписался 3 раза на одну группу], [Количество уникальных подписчиков: 1], [Успешно выполнен],
    
    [24], [Подсчет просмотров по типу: RoomSchedule], [2 пользователя просмотрели RoomSchedule, 1 — GroupSchedule], [Количество уникальных: 2 (только RoomSchedule)], [Успешно выполнен],
    
    [25], [Подсчет просмотров по типу: GroupSchedule], [2 пользователя просмотрели GroupSchedule, 1 — RoomSchedule], [Количество уникальных: 2 (только GroupSchedule)], [Успешно выполнен],
    
    [26], [Подсчет просмотров по типу: Teacher Schedule], [2 пользователя просмотрели TeacherSchedule, 1 — RoomSchedule], [Количество уникальных: 2 (только TeacherSchedule)], [Успешно выполнен],
    
    [27], [Статистика настроек: последнее обновление], [user1: default→custom (last), user2: custom→default (last)], [Custom: 1 (user1), Default: 1 (user2)], [Успешно выполнен],
    
    [28], [Игнорирование событий не-настроек], [1 SetCustomSettings, 1 Registered, 1 SubscribedToGroup для одного пользователя], [Количество с custom настройками: 1], [Успешно выполнен],
    
    [29], [Подсчет пользователей, выполнявших поиск], [3 пользователя, каждый выполнил запрос Search], [Количество уникальных: 3], [Успешно выполнен],
    
    [30], [Исключение дубликатов в поиске], [1 пользователь выполнил 3 поисковых запроса], [Количество уникальных: 1], [Успешно выполнен],
    
    [31], [Фильтрация поиска по датам], [3 пользователя искали в разные даты (01.2024, 02.2024, 03.2024), диапазон: 02-03.2024], [Количество: 2 (исключен январь)], [Успешно выполнен],
    
    [32], [Валидация GetTopGroups ByRequests Query: top=0], [Параметр top=0, min=1], [InvalidParameter Exception с указанием минимума], [Успешно выполнен],
    
    [33], [Валидация GetTopGroups ByRequests Query: top=-5], [Параметр top=-5, min=1], [InvalidParameter Exception с указанием минимума], [Успешно выполнен],
    
    [34], [Валидация GetTopGroups BySubscribers Query: top вне диапазона], [Параметр top=101, max=100], [InvalidParameter Exception с указанием максимума], [Успешно выполнен],
    
    [35], [Валидация дат в GetUnique Schedule Viewers CountQuery], [from=31.12.2024, to=01.01.2024], [InvalidDate RangeException], [Успешно выполнен],
    
    [36], [Валидация дат в GetGroup Schedule Requests CountQuery], [from=30.06.2024, to=01.01.2024], [InvalidDate RangeException], [Успешно выполнен],
    
    [37], [Обработка Format Exception], [Middleware получает FormatException], [HTTP 400 + "Некорректный формат данных"], [Успешно выполнен],
    
    [38], [Обработка Unauthorized Access Exception], [Middleware получает Unauthorized Access Exception], [HTTP 403 + "Доступ запрещен"], [Успешно выполнен],
    
    [39], [Обработка Operation Canceled Exception], [Middleware получает OperationCanceled Exception], [HTTP 499 + "Запрос был отменен"], [Успешно выполнен],
    
    [40], [Обработка Invalid  Operation Exception с "no elements"], [Middleware получает InvalidOperation Exception("Sequence contains no elements")], [HTTP 404 + "Запрашиваемые данные не найдены"], [Успешно выполнен],
    
    [41], [Middleware пропускает запросы без ошибок], [Запрос обработан успешно без исключений], [HTTP 204 No Content, пустое тело ответа], [Успешно выполнен],
    
    [42], [Формат JSON ответа middleware], [Любое исключение], [Content-Type: application/json, поля: status, detail], [Успешно выполнен],
    
    [43], [Фильтрация по диапазону дат для GetRegistered UsersCount Query], [3 пользователя (01.2024, 02.2024, 03.2024), диапазон: 01.02-28.02.2024], [Количество: 1 (только февраль)], [Успешно выполнен],
    
    [44], [Валидация DateRange: from=null, корректное поведение], [from=null, to=31.12.2024], [Исключение не выбрасывается, фильтрация только по to], [Успешно выполнен],
    
    [45], [Валидация DateRange: to=null, корректное поведение], [from=01.01.2024, to=null], [Исключение не выбрасывается, фильтрация только по from], [Успешно выполнен],
    
    [46], [Топ групп по запросам: несколько пользователей на одну группу], [group-a: 1 пользователь выполнил 3 запроса, 1 пользователь - 2 запроса], [Total requests: 5 для group-a], [Успешно выполнен],
    
    [47], [Топ групп по подписчикам: ограничение по датам], [3 группы с подписчиками в разные даты, фильтр by date], [Возвращаются только группы в указанном диапазоне], [Успешно выполнен],
    
    [48], [GetUnique Schedule Viewers CountQuery: фильтрация по диапазону], [4 пользователя просмотрели расписание в разные даты, from=date2, to=date3], [Количество: 2 (в диапазоне)], [Успешно выполнен],
    
    [49], [GetGroup Schedule Requests CountQuery: фильтрация по to], [3 запроса в разные даты (01.2024, 02.2024, 03.2024), to=10.02.2024], [Количество: 2 (до 10.02 включительно)], [Успешно выполнен],
    
    [50], [GetGroup Schedule Requests CountQuery: фильтрация по диапазону], [3 запроса, from=01.02.2024, to=28.02.2024], [Количество: 1 (только в феврале)], [Успешно выполнен],
    
    [51], [Топ групп по запросам: фильтрация по диапазону дат], [3 группы с запросами в разные даты, диапазон: 01-31.02.2024], [Возвращаются только запросы в указанном диапазоне], [Успешно выполнен],
    
    [52], [Топ групп по запросам: пустой результат при отсутствии данных], [База данных пуста], [Возвращается пустой список], [Успешно выполнен],
    
    [53], [Топ групп по подписчикам: пустой результат], [База данных пуста или нет подписок], [Возвращается пустой список], [Успешно выполнен],
    
    [54], [GetUnique Schedule Viewers CountQuery: пустой результат], [База данных пуста], [Возвращается 0], [Успешно выполнен],
    
    [55], [GetRegistered Users CountQuery: пустой результат], [База данных пуста], [Возвращается 0], [Успешно выполнен],
    
    [56], [Валидация чисел: граничные значения min], [top=1 (минимум), min=1, max=100], [Исключение не выбрасывается], [Успешно выполнен],
    
    [57], [Валидация чисел: граничные значения max], [top=100 (максимум), min=1, max=100], [Исключение не выбрасывается], [Успешно выполнен],
    
    [58], [Валидация чисел: кастомный диапазон 5-10], [value=7, min=5, max=10], [Исключение не выбрасывается], [Успешно выполнен],
    
    [59], [Валидация чисел: кастомный диапазон, ниже минимума], [value=4, min=5, max=10], [InvalidParameter Exception], [Успешно выполнен],
    
    [60], [Валидация чисел: кастомный диапазон, выше максимума], [value=11, min=5, max=10], [InvalidParameter Exception], [Успешно выполнен],
    
    [61], [Валидация чисел: проверка дефолтного диапазона], [value=500, no min/max specified (default 1-1000)], [Исключение не выбрасывается], [Успешно выполнен],
    
    [62], [Валидация чисел: превышение дефолтного максимума], [value=1001, default max=1000], [InvalidParameter  Exception с упоминанием 1000], [Успешно выполнен],
    
    [63], [Валидация чисел: сообщение содержит имя параметра], [Любой некорректный параметр "mySpecialParameter"], [InvalidParameter Exception. ParameterName == "mySpecial Parameter"], [Успешно выполнен],
    
    [64], [DateRange валидация: дата в прошлом валидна], [Дата 30 дней назад], [Исключение не выбрасывается], [Успешно выполнен],
    
    [65], [DateRange валидация: null дата валидна], [date=null], [Исключение не выбрасывается], [Успешно выполнен],
    
    [66], [DateRange валидация: сообщение содержит ISO даты], [from=2024-12-31, to=2024-01-01], [Сообщение содержит "2024-12-31" и "2024-01-01"], [Успешно выполнен],
    
    [67], [UserSettings: нулевой результат при отсутствии настроек], [База данных не содержит событий настроек], [Custom: 0, Default: 0], [Успешно выполнен],
    
    [68], [User Settings: множественные изменения одного пользователя], [user1: default→custom→ default→custom], [Учитывается только последнее: custom], [Успешно выполнен],
    
    [69], [UsersWho SetCustom Settings: исключение SetDefault Settings], [2 пользователя: 1 SetCustomSettings, 1 SetDefaultSettings], [Количество: 1 (только custom)], [Успешно выполнен],
    
    [70], [UsersWho SetCustom Settings: без дубликатов], [1 пользователь установил custom 3 раза], [Количество: 1 (distinct)], [Успешно выполнен],
    
    [71], [Search: исключение других типов запросов], [3 пользователя: 2 Search, 1 GroupSchedule], [Количество: 2 (только Search)], [Успешно выполнен],
    
    [72], [Schedule Viewers: RoomSchedule без дубликатов], [1 пользователь выполнил 3 RoomSchedule запроса], [Количество: 1 (distinct)], [Успешно выполнен],
    
    [73], [Schedule Viewers: GroupSchedule без дубликатов], [1 пользователь выполнил 3 GroupSchedule запроса], [Количество: 1 (distinct)], [Успешно выполнен],
    
    [74], [Schedule Viewers: Teacher Schedule без дубликатов], [1 пользователь выполнил 3 TeacherSchedule запроса], [Количество: 1 (distinct)], [Успешно выполнен],
    
    [75], [Schedule Viewers: фильтрация по датам для всех типов], [3 пользователя просмотрели RoomSchedule в разные даты, диапазон: date2-date3], [Количество: 2 (в диапазоне)], [Успешно выполнен],
    
    [76], [Validation Exception: обработка как 400], [Middleware получает ValidationException ("Общая ошибка валидации")], [HTTP 400 + "Общая ошибка валидации"], [Успешно выполнен],
    
    [77], [Middleware: формат ответа только status и detail], [Любое исключение (например, InvalidParameter Exception)], [Response содержит только поля status и detail, нет стек-трейса], [Успешно выполнен],
  ),
  caption: "Результаты тестирования основных сценариев",
  kind: table
)<tbl-test-results>>



== Статистика покрытия тестами

Всего разработано 12 тестовых классов с более чем 100 индивидуальными тестовыми случаями. Все тесты успешно пройдены, что подтверждает корректность реализации функциональных требований микросервиса.

На рисунке @fig-test-results показано успешное выполнение юнит тестов; представлены итоговые результаты тестового прогона.

#figure(
  image("images/test-results.png"),
  caption: [Результаты выполнения юнит тестов],
  kind: image
) <fig-test-results>

В таблице @table-test-coverage представлена детализация покрытия тестами по классам и слоям приложения, включая количество тестовых методов и описание проверяемой функциональности для каждого компонента системы.

#figure(
  long-table(
    columns: (2fr, 1fr, 2fr),
    align: (left, center, left),
    inset: 6pt,
    [*Тестовый класс*], [*Кол-во тестов*], [*Описание*],
    table.cell(colspan: 3, align: center)[*Application Layer (Queries)*],
 [GetRegisteredUsersCount
 QueryHandlerTests], [5], [Подсчет зарегистрированных пользователей с фильтрацией],
    
     [GetUniqueScheduleViewersCount
     QueryHandlerTests], [6], [Подсчет уникальных пользователей, просматривавших расписание],
    
     [GetGroupScheduleRequests
     CountQueryHandlerTests], [6], [Количество просмотров расписания групп],
    
     [GetTopGroupsByRequestsQuery
     HandlerTests], [8], [Топ групп по количеству запросов],
    
     [GetTopGroupsBySubscribersQuery
     HandlerTests], [8], [Топ групп по количеству подписчиков],
    
     [ScheduleViewersByTypeQuery
     HandlerTests], [6], [Статистика просмотров по типам (Room, Group, Teacher)],
    
     [SearchQueryHandlerTests], [6], [Статистика поисковых запросов],
    
     [UserSettingsQueryHandlerTests], [7], [Статистика по настройкам пользователей],
    
     [QueryValidationTests], [12+], [Валидация параметров всех query handlers],
    table.cell(colspan: 3, align: center)[*Application Layer (Validators)*], 
    [DateRangeValidatorTests], [9], [Валидация диапазонов дат],
    
     [NumericParameterValidatorTests], [20+], [Валидация числовых параметров (8 параметризованных тестов)],
    
    table.cell(colspan: 3, align: center)[*WebApi Layer*], [ExceptionHandlingMiddlewareTests], [8+], [Обработка исключений и HTTP статус-коды],
  ),
  caption: "Покрытие тестами по слоям и компонентам приложения",
  kind: table
)<table-test-coverage>

В таблице @table-test-technologies представлены типы и цели проверяемых тестовых сценариев, применяемые при верификации функциональности микросервиса, включая позитивные, негативные и граничные случаи, а также сценарии функциональной проверки и валидации входных данных.

#figure(
  long-table(
    columns: (1fr, 2fr),
    align: (left, left),
    inset: 6pt,
    [*Тип сценария*], [*Описание и проверяемая функциональность*],
    [Позитивные], [Проверка корректной работы системы при валидных входных данных и нормальных условиях функционирования],
    [Негативные], [Проверка обработки ошибок и корректного поведения при некорректных или неожиданных данных],
    [Граничные], [Проверка поведения при null параметрах, равных датах, экстремальных значениях и пустых наборах данных],
    [Фильтрация и сортировка], [Проверка корректности выборки и упорядочения результатов по различным критериям],
    [Валидация входных параметров], [Проверка выявления и обработки некорректных значений всех API endpoints],
    [Отображение исключений], [Проверка корректного преобразования исключений в HTTP статус-коды для коммуникации ошибок],
  ),
  caption: "Типы и описание проверяемых тестовых сценариев",
  kind: table
)<table-test-scenarios>

В таблице @table-test-technologies представлены основные технологии и инструменты, используемые при разработке и выполнении тестового покрытия микросервиса, включая фреймворки, библиотеки и методики параметризованного тестирования и верификации результатов.

#figure(
  long-table(
    columns: (1fr, 2fr),
    align: (left, left),
    inset: 6pt,
    [*Технология*], [*Назначение и область применения*],
    [Xunit], [Фреймворк для модульного тестирования в .NET с удобным синтаксисом и расширяемостью],
    [InMemoryDatabase], [Обеспечение изоляции тестов базы данных без подключения к реальной БД через Entity Framework Core],
    [Theory и InlineData], [Параметризованное тестирование с множеством входных значений в одном тесте],
    [Assert методы], [Проверка ожидаемых результатов через Equal, Throws, Contains и другие проверки],
    [Record.Exception], [Перехват и проверка исключений для верификации обработки ошибок],
  ),
  caption: "Используемые технологии и инструменты тестирования",
  kind: table
)<table-test-technologies>

== Выводы по тестированию

Все разработанные функциональные возможности микросервиса прошли успешное тестирование. Проверены как успешные сценарии работы (получение статистики с различными фильтрами), так и режимы обработки ошибок (некорректные параметры, отсутствующие данные, исключительные ситуации).

Использование in-memory базы данных и параметризованных тестов обеспечивает высокую скорость выполнения тестов и их независимость друг от друга. Каждый тест создает изолированное окружение, что гарантирует воспроизводимость результатов.

Тестовое покрытие включает все критические компоненты системы: обработчики запросов, валидаторы входных данных и middleware обработки ошибок. Все тесты выполняются успешно, что подтверждает корректность реализации требований.

#pagebreak()

#ch("Заключение")

В ходе выполнения курсовой работы была успешно разработана система аналитики для Telegram-бота расписания ГУАП — микросервис SuaiScheduleBotAnalytics, который решает задачу сбора, хранения и анализа метрик использования основного приложения.

*Достигнутые результаты.* Спроектирована архитектура микросервиса в соответствии с принципами Clean Architecture, обеспечивающая четкое разделение ответственности и легкость тестирования. Реализованы четыре архитектурных слоя: Domain определяет доменные сущности (User, Group, Request, Update), Application реализует бизнес-логику через MediatR команды и запросы с потребителями Kafka, Infrastructure настраивает работу с PostgreSQL через Entity Framework Core, WebApi создает REST API с документацией Swagger. Разработаны асинхронные потребители Kafka для обработки событий от основного бота в реальном времени без влияния на его производительность. Создан REST API с endpoints для получения метрик и статистики использования бота, с поддержкой фильтрации по времени и валидацией входных данных. Обеспечена надежность через обработку ошибок, retry-логику и graceful shutdown. Подготовлена Docker Compose конфигурация для развертывания в dev и production. Сформирована документация API через Swagger/OpenAPI для упрощения интеграции.

*Ключевые характеристики решения.* Масштабируемость достигается за счет асинхронной архитектуры и возможности обработки растущих объемов данных. Надежность обеспечивается потребителями Kafka с гарантированной доставкой, retry-логикой и обработкой отказов. Поддерживаемость усилена благодаря принципам Clean Architecture и строгому разделению ответственности. Производительность поддерживается асинхронными операциями и оптимизацией запросов.

*Возможные направления улучшения.* Добавление Redis кэша для часто запрашиваемых данных уменьшит нагрузку на базу. Реализация real-time dashboard для визуализации метрик улучшит мониторинг. Включение ML алгоритмов для прогноза пиков использования позволит оптимизировать инфраструктуру. Расширение аналитики на ошибки основного бота повысит качество обслуживания. Внедрение мониторинга и алертинга на базе метрик обеспечит проактивное реагирование. Увеличение набора unit и integration тестов повысит надежность. Оптимизация производительности через пулинг соединений и батчинг ускорит обработку больших объемов данных.

*Область практического применения.* Разработанный микросервис подходит администраторам для мониторинга использования бота, выявления популярных групп, анализа пиковых периодов и оптимизации работы основного сервиса. Методология может применяться для создания аналитических систем других Telegram-ботов и веб-приложений, где требуется сбор и анализ метрик пользовательского поведения.

#pagebreak()
#ch("СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ")
#v(0.8em)

+ Мартин Р. К. Clean Architecture : A Craftsman's Guide to Software Structure and Design / Р. К. Мартин. — Boston : Prentice Hall, 2017. — 432 с.

+ Эванс Э. Domain-Driven Design : Tackling Complexity in the Heart of Software / Э. Эванс. — Boston : Addison-Wesley, 2003. — 529 с.

+ Ньюман С. Building Microservices : Designing Fine-Grained Systems / С. Ньюман. — Boston : O’Reilly Media, 2015. — 280 с.

+ ASP.NET Core documentation [Электронный ресурс]. — URL: https://docs.microsoft.com/en-us/aspnet/core/ (дата обращения: 16.12.2025).

+ Entity Framework Core documentation [Электронный ресурс]. — URL: https://docs.microsoft.com/en-us/ef/core/ (дата обращения: 16.12.2025).

+ Apache Kafka Documentation [Электронный ресурс]. — URL: https://kafka.apache.org/documentation/ (дата обращения: 16.12.2025).

+ MassTransit Documentation [Электронный ресурс]. — URL: https://masstransit.io/ (дата обращения: 16.12.2025).

+ MediatR Documentation [Электронный ресурс]. — URL: https://github.com/jbogard/MediatR (дата обращения: 16.12.2025).

+ PostgreSQL Documentation [Электронный ресурс]. — URL: https://www.postgresql.org/docs/ (дата обращения: 16.12.2025).

+ Docker Documentation [Электронный ресурс]. — URL: https://docs.docker.com/ (дата обращения: 16.12.2025).


#pagebreak()
#{
  show heading: none
  align(heading([ПРИЛОЖЕНИЕ A. Код программы], numbering: none), center)
}

#align([*ПРИЛОЖЕНИЕ A. \ Код программы*], center)
#v(0.8em)

BaseEntity.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.Models/Entities/BaseEntity.cs"), lang: "cs", block: true)

UserEntity.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.Models/Entities/UserEntity.cs"), lang: "cs", block: true)

RequestEntity.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.Models/Entities/RequestEntity.cs"), lang: "cs", block: true)

GroupEntity.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.Models/Entities/GroupEntity.cs"), lang: "cs", block: true)

UpdateEntity.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.Models/Entities/UpdateEntity.cs"), lang: "cs", block: true)

KafkaOptions.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.Models/Options/KafkaOptions.cs"), lang: "cs", block: true)

InvalidDateRangeException.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.Models/Exceptions/InvalidDateRangeException.cs"), lang: "cs", block: true)

InvalidParameterException.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.Models/Exceptions/InvalidParameterException.cs"), lang: "cs", block: true)

ValidationException.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.Models/Exceptions/ValidationException.cs"), lang: "cs", block: true)

IAnalyticsDbContext.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.Application/Abstract/IAnalyticsDbContext.cs"), lang: "cs", block: true)

GroupScheduleCommand.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.Application/Commands/UserRequests/GroupScheduleCommand.cs"), lang: "cs", block: true)

TeacherScheduleCommand.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.Application/Commands/UserRequests/TeacherScheduleCommand.cs"), lang: "cs", block: true)

RoomScheduleCommand.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.Application/Commands/UserRequests/RoomScheduleCommand.cs"), lang: "cs", block: true)

SearchCommand.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.Application/Commands/UserRequests/SearchCommand.cs"), lang: "cs", block: true)

RegisterUserCommand.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.Application/Commands/UserUpdates/RegisterUserCommand.cs"), lang: "cs", block: true)

SubscribeUserToGroupCommand.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.Application/Commands/UserUpdates/SubscribeUserToGroupCommand.cs"), lang: "cs", block: true)

SetUserCustomSettingsCommand.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.Application/Commands/UserUpdates/SetUserCustomSettingsCommand.cs"), lang: "cs", block: true)

SetUserDefaultSettingsCommand.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.Application/Commands/UserUpdates/SetUserDefaultSettingsCommand.cs"), lang: "cs", block: true)

GetRegisteredUsersCountQuery.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.Application/Queries/GetRegisteredUsersCountQuery.cs"), lang: "cs", block: true)

GetUniqueScheduleViewersCountQuery.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.Application/Queries/GetUniqueScheduleViewersCountQuery.cs"), lang: "cs", block: true)

GetUniqueGroupScheduleViewersCountQuery.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.Application/Queries/GetUniqueGroupScheduleViewersCountQuery.cs"), lang: "cs", block: true)

GetUniqueTeacherScheduleViewersCountQuery.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.Application/Queries/GetUniqueTeacherScheduleViewersCountQuery.cs"), lang: "cs", block: true)

GetUniqueRoomScheduleViewersCountQuery.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.Application/Queries/GetUniqueRoomScheduleViewersCountQuery.cs"), lang: "cs", block: true)
GetGroupScheduleRequestsCountQuery.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.Application/Queries/GetGroupScheduleRequestsCountQuery.cs"), lang: "cs", block: true)

GetTopGroupsByRequestsQuery.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.Application/Queries/GetTopGroupsByRequestsQuery.cs"), lang: "cs", block: true)

GetTopGroupsBySubscribersQuery.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.Application/Queries/GetTopGroupsBySubscribersQuery.cs"), lang: "cs", block: true)

GetSearchRequestsCountQuery.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.Application/Queries/GetSearchRequestsCountQuery.cs"), lang: "cs", block: true)

GetUniqueUsersWhoSearchedCountQuery.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.Application/Queries/GetUniqueUsersWhoSearchedCountQuery.cs"), lang: "cs", block: true)

GetUsersWithCustomSettingsCountQuery.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.Application/Queries/GetUsersWithCustomSettingsCountQuery.cs"), lang: "cs", block: true)

GetUsersWhoSetCustomSettingsCountQuery.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.Application/Queries/GetUsersWhoSetCustomSettingsCountQuery.cs"), lang: "cs", block: true)

GetUsersWithDefaultSettingsCountQuery.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.Application/Queries/GetUsersWithDefaultSettingsCountQuery.cs"), lang: "cs", block: true)

DateRangeValidator.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.Application/Validators/DateRangeValidator.cs"), lang: "cs", block: true)

NumericParameterValidator.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.Application/Validators/NumericParameterValidator.cs"), lang: "cs", block: true)

UserPerformedRequestConsumer.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.Application/Kafka/UserPerformedRequestConsumer.cs"), lang: "cs", block: true)

UserUpdatedMessageConsumer.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.Application/Kafka/UserUpdatedMessageConsumer.cs"), lang: "cs", block: true)

AnalyticsDbContext.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.DataLayer.EF/AnalyticsDbContext.cs"), lang: "cs", block: true)

UserEntityConfiguration.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.DataLayer.EF/Configuration/UserEntityConfiguration.cs"), lang: "cs", block: true)

GroupEntityConfiguration.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.DataLayer.EF/Configuration/GroupEntityConfiguration.cs"), lang: "cs", block: true)

RequestEntityConfiguration.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.DataLayer.EF/Configuration/RequestEntityConfiguration.cs"), lang: "cs", block: true)

UpdateEntityConfiguration.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.DataLayer.EF/Configuration/UpdateEntityConfiguration.cs"), lang: "cs", block: true)

Program.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.WebApi/Program.cs"), lang: "cs", block: true)

StatisticsController.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.WebApi/StatisticsController.cs"), lang: "cs", block: true)

ExceptionHandlingMiddleware.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.WebApi/Middleware/ExceptionHandlingMiddleware.cs"), lang: "cs", block: true)

OpenApiExportMiddleware.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.WebApi/Middleware/OpenApiExportMiddleware.cs"), lang: "cs", block: true)

20251208203602_Initial.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.DataLayer.EF/Migrations/20251208203602_Initial.cs"), lang: "cs", block: true)

20251208203602_Initial.Designer.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.DataLayer.EF/Migrations/20251208203602_Initial.Designer.cs"), lang: "cs", block: true)

20251214195506_AddFKs.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.DataLayer.EF/Migrations/20251214195506_AddFKs.cs"), lang: "cs", block: true)

20251214195506_AddFKs.Designer.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.DataLayer.EF/Migrations/20251214195506_AddFKs.Designer.cs"), lang: "cs", block: true)

AnalyticsDbContextModelSnapshot.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/src/SuaiScheduleBotAnalytics.DataLayer.EF/Migrations/AnalyticsDbContextModelSnapshot.cs"), lang: "cs", block: true)

Program.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/DatabaseSeeder/Program.cs"), lang: "cs", block: true)

UserRequestTypes.cs
#raw(read("../../AI/SuaiScheduleBot/SuaiScheduleBot.Contracts/Constants/UserRequestTypes.cs"), lang: "cs", block: true)

UserUpdateTypes.cs
#raw(read("../../AI/SuaiScheduleBot/SuaiScheduleBot.Contracts/Constants/UserUpdateTypes.cs"), lang: "cs", block: true)

BaseUserMessage.cs
#raw(read("../../AI/SuaiScheduleBot/SuaiScheduleBot.Contracts/Kafka/BaseUserMessage.cs"), lang: "cs", block: true)

IdentifiersSyncMessage.cs
#raw(read("../../AI/SuaiScheduleBot/SuaiScheduleBot.Contracts/Kafka/Messages/IdentifiersSyncMessage.cs"), lang: "cs", block: true)

UserPerformedRequestMessage.cs
#raw(read("../../AI/SuaiScheduleBot/SuaiScheduleBot.Contracts/Kafka/Messages/UserPerformedRequestMessage.cs"), lang: "cs", block: true)

UserUpdatedMessage.cs
#raw(read("../../AI/SuaiScheduleBot/SuaiScheduleBot.Contracts/Kafka/Messages/UserUpdatedMessage.cs"), lang: "cs", block: true)

ExceptionHandlingMiddlewareTests.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/tests/SuaiScheduleBotAnalytics.Tests/WebApi/ExceptionHandlingMiddlewareTests.cs"), lang: "cs", block: true)

GetRegisteredUsersCountQueryHandlerTests.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/tests/SuaiScheduleBotAnalytics.Tests/Application/QueryHandlers/GetRegisteredUsersCountQueryHandlerTests.cs"), lang: "cs", block: true)

GetGroupScheduleRequestsCountQueryHandlerTests.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/tests/SuaiScheduleBotAnalytics.Tests/Application/QueryHandlers/GetGroupScheduleRequestsCountQueryHandlerTests.cs"), lang: "cs", block: true)

GetUniqueScheduleViewersCountQueryHandlerTests.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/tests/SuaiScheduleBotAnalytics.Tests/Application/QueryHandlers/GetUniqueScheduleViewersCountQueryHandlerTests.cs"), lang: "cs", block: true)

GetTopGroupsByRequestsQueryHandlerTests.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/tests/SuaiScheduleBotAnalytics.Tests/Application/QueryHandlers/GetTopGroupsByRequestsQueryHandlerTests.cs"), lang: "cs", block: true)

GetTopGroupsBySubscribersQueryHandlerTests.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/tests/SuaiScheduleBotAnalytics.Tests/Application/QueryHandlers/GetTopGroupsBySubscribersQueryHandlerTests.cs"), lang: "cs", block: true)

ScheduleViewersByTypeQueryHandlerTests.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/tests/SuaiScheduleBotAnalytics.Tests/Application/QueryHandlers/ScheduleViewersByTypeQueryHandlerTests.cs"), lang: "cs", block: true)

UserSettingsQueryHandlerTests.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/tests/SuaiScheduleBotAnalytics.Tests/Application/QueryHandlers/UserSettingsQueryHandlerTests.cs"), lang: "cs", block: true)

SearchQueryHandlerTests.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/tests/SuaiScheduleBotAnalytics.Tests/Application/QueryHandlers/SearchQueryHandlerTests.cs"), lang: "cs", block: true)

QueryValidationTests.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/tests/SuaiScheduleBotAnalytics.Tests/Application/QueryHandlers/QueryValidationTests.cs"), lang: "cs", block: true)

DateRangeValidatorTests.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/tests/SuaiScheduleBotAnalytics.Tests/Application/Validators/DateRangeValidatorTests.cs"), lang: "cs", block: true)

NumericParameterValidatorTests.cs
#raw(read("../../AI/SuaiScheduleBotAnalytics/tests/SuaiScheduleBotAnalytics.Tests/Application/Validators/NumericParameterValidatorTests.cs"), lang: "cs", block: true)