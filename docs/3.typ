#import "lib/gost.typ": *
#import "lib/titlepage.typ": *



#show: doc => init(doc)
= Анализ предметной области
-
= Разработка требований к программе
-
= Проектирование структуры программы
== Архитектурные слои микросервиса
=== Domain Layer 
Содержит доменные модели, которые независимы от деталей реализации и внешних зависимостей. На данном уровне определяются бизнес-правила и инварианты. Доменные сущности и перечисления отражают ключевые понятия предметной области, формируют устойчивые контракты и не зависят от технологий хранения данных или транспорта. Здесь фиксируются инварианты (например, корректность временных меток, допустимые значения перечислений), вводятся value-объекты и соглашения, повышающие выразительность модели. Благодаря отсутствию инфраструктурных зависимостей, доменный слой легко покрывается модульными тестами и служит опорой для эволюции системы.

\
=== Application Layer
Содержит бизнес-логику приложения, включая use cases, команды, запросы (queries), валидаторы и потребителей Kafka. Использует паттерн MediatR для управления командами и запросами. Слой реализует принципы CQRS: команды изменяют состояние, а запросы предназначены для чтения и агрегирования данных. Обработчики (handlers) оркестрируют сценарии, применяют валидаторы параметров, обеспечивают идемпотентность и устойчивость к повторной доставке событий. Интеграция с брокером сообщений и внешними источниками выполняется через абстракции, что упрощает тестирование и замену провайдеров.

\
=== Infrastructure Layer
Реализует интерфейсы репозиториев, работу с БД через Entity Framework Core, миграции и конфигурацию EF. Здесь определяются сопоставления сущностей (mapping), индексы и ограничения, настраиваются политики транзакций и повторных попыток (connection resiliency). Репозитории предоставляют типовые операции доступа к данным, а миграции позволяют эволюционировать схему без потери целостности. Инфраструктурные компоненты изолированы за контрактами, что дает возможность использовать in-memory хранилище для тестов и переключать СУБД при необходимости.

\
=== API Layer
Содержит REST контроллеры, конфигурацию Swagger/OpenAPI и middleware для обработки HTTP запросов. Контроллеры выступают тонкими адаптерами: принимают параметры HTTP, формируют команды/запросы и делегируют выполнение в Application слой через MediatR. Документация генерируется автоматически на основе аннотаций и XML-комментариев, а единый middleware преобразует исключения в согласованные HTTP коды и JSON ответы. Слой предусматривает поддержку версионирования API и механизмов авторизации при необходимости, оставаясь свободным от бизнес-логики.
#pagebreak()

\ 
== Взаимосвязь уровней компонентов
=== Уровень потребления событий (Kafka Consumers)
Поток данных в систему начинается с асинхронных потребителей событий, подписанных на топики Apache Kafka. Компоненты UserPerformedRequestConsumer и UserUpdatedMessageConsumer непрерывно прослушивают соответствующие топики suai.user-performed-request и suai.user-updated-message. При поступлении нового события потребитель десериализует сообщение в строго типизированную модель (UserPerformedRequestMessage или UserUpdatedMessage), выполняет базовую валидацию данных и проверяет наличие пользователя в базе данных. Если пользователь отсутствует, система автоматически создает новую запись. Затем потребитель на основе типа события формирует соответствующую команду MediatR и передает её в обработчик.

\
=== Уровень бизнес-логики (MediatR Commands и Queries)
Паттерн MediatR обеспечивает разделение запросов на команды (изменяющие состояние системы) и запросы (только читающие данные). Команды включают GroupScheduleCommand, SubscribeUserToGroupCommand, RegisterUserCommand, SetUserCustomSettingsCommand и другие. Каждая команда инкапсулирует намерение выполнить определенное бизнес-действие с необходимыми параметрами. Запросы (Queries) реализуют паттерн CQRS и включают GetRegisteredUsersCountQuery, GetTopGroupsBySubscribersQuery, GetTopGroupsByRequestsQuery и множество других запросов для получения аналитических данных. Каждая команда и запрос обрабатывается специализированным Handler'ом, содержащим бизнес-логику обработки.

\
=== Уровень обработчиков (Command и Query Handlers)
Обработчики команд отвечают за сохранение событий в базе данных. Например, GroupScheduleCommandHandler проверяет наличие группы в системе, создает её при необходимости с нормализованным названием, формирует сущность RequestEntity и сохраняет её транзакционно через интерфейс IAnalyticsDbContext. Обработчики запросов реализуют сложную аналитическую логику с использованием LINQ запросов. Например, GetTopGroupsBySubscribersQueryHandler извлекает события подписок, фильтрует их по временному диапазону, для каждого пользователя определяет последнюю подписку (чтобы учесть смену группы), группирует результаты по названию группы, подсчитывает уникальных подписчиков, сортирует группы по убыванию количества подписчиков и ограничивает результат параметром top. Все обработчики используют валидаторы DateRangeValidator и NumericParameterValidator для проверки входных параметров перед выполнением операций.

\
=== Уровень доступа к данным (Repository и IAnalyticsDbContext)
Интерфейс IAnalyticsDbContext абстрагирует детали работы с базой данных и предоставляет типизированные DbSet для каждой доменной сущности: Users (пользователи), Groups (группы), Requests (запросы на просмотр расписания), Updates (события обновления пользователей). Этот интерфейс определяет контракт для операций с данными и позволяет легко подменять реализацию для тестирования. Обработчики команд и запросов зависят только от интерфейса, а не от конкретной реализации, что соответствует принципу инверсии зависимостей (Dependency Inversion Principle).

\
=== Уровень персистентности (Entity Framework Core и PostgreSQL)
Класс AnalyticsDbContext наследует DbContext из Entity Framework Core и реализует интерфейс IAnalyticsDbContext. Конфигурация сущностей выполняется через Fluent API в отдельных классах конфигурации (EntityTypeConfiguration), что обеспечивает разделение конфигурационной логики от бизнес-моделей. Миграции базы данных управляются через EF Core Migrations, что позволяет версионировать схему БД и безопасно применять изменения. PostgreSQL выбран в качестве СУБД благодаря поддержке JSONB для хранения сложных структур данных, высокой производительности при аналитических запросах и надежности при высоких нагрузках. Индексы создаются на часто используемых полях (UserId, GroupId, OccuredAt, RequestType, UpdateType) для оптимизации запросов.

\
=== Уровень представления (REST API Controllers)
Класс StatisticsController наследует ControllerBase и предоставляет HTTP endpoints для получения аналитических данных. Каждый метод контроллера принимает параметры из HTTP запроса (query string или route parameters), создает соответствующий Query объект MediatR, отправляет его через IMediator.Send() и возвращает результат в формате JSON. Контроллер не содержит бизнес-логики — он выполняет роль тонкого адаптера между HTTP протоколом и внутренней архитектурой приложения. Swagger/OpenAPI автоматически генерирует документацию API на основе аннотаций и XML-комментариев, предоставляя интерактивный интерфейс для тестирования endpoints.

\
=== Обработка ошибок и валидация
Глобальный middleware ExceptionHandlingMiddleware перехватывает все исключения, возникающие в процессе обработки запроса, преобразует их в соответствующие HTTP статус-коды (400 для невалидных параметров, 404 для ненайденных ресурсов, 409 для конфликтов, 500 для внутренних ошибок) и формирует унифицированный JSON ответ с полями status и detail. Валидаторы DateRangeValidator и NumericParameterValidator выбрасывают типизированные исключения InvalidDateRangeException и InvalidParameterException с подробными сообщениями об ошибках, что обеспечивает информативную обратную связь для клиентов API.

\
== Преимущества архитектуры
Данная организация компонентов обеспечивает четкое разделение ответственности между слоями, упрощает тестирование за счет внедрения зависимостей через интерфейсы, позволяет независимо масштабировать компоненты обработки событий и обслуживания HTTP запросов, облегчает поддержку и расширение системы благодаря слабой связанности модулей, и гарантирует соответствие принципам SOLID и Clean Architecture.
\ 